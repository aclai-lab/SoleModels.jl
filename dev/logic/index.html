<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Logical foundations · SoleModels.jl</title><meta name="title" content="Logical foundations · SoleModels.jl"/><meta property="og:title" content="Logical foundations · SoleModels.jl"/><meta property="twitter:title" content="Logical foundations · SoleModels.jl"/><meta name="description" content="Documentation for SoleModels.jl."/><meta property="og:description" content="Documentation for SoleModels.jl."/><meta property="twitter:description" content="Documentation for SoleModels.jl."/><meta property="og:url" content="https://aclai-lab.github.io/SoleModels.jl/logic/"/><meta property="twitter:url" content="https://aclai-lab.github.io/SoleModels.jl/logic/"/><link rel="canonical" href="https://aclai-lab.github.io/SoleModels.jl/logic/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="SoleModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SoleModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Logical foundations</a></li><li><a class="tocitem" href="../models/">Symbolic models</a></li><li><a class="tocitem" href="../parse/">Parsing models from other frameworks</a></li><li><a class="tocitem" href="../autodocs/">Full reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Logical foundations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Logical foundations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleModels.jl/blob/main/docs/src/logic.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Logical-foundations"><a class="docs-heading-anchor" href="#Logical-foundations">Logical foundations</a><a id="Logical-foundations-1"></a><a class="docs-heading-anchor-permalink" href="#Logical-foundations" title="Permalink"></a></h1><p><a href="https://github.com/aclai-lab/SoleLogics.jl">SoleLogics</a> lays the logical foundations for this package. While the full reference for SoleLogics can be found <a href="https://aclai-lab.github.io/SoleLogics.jl/">here</a>, these are the basic logical concepts needed for <em>symbolic modelling</em>.</p><ul><li><a href="../autodocs/#SoleModels.AbstractModel"><code>SoleModels.AbstractModel</code></a></li><li><a href="../autodocs/#SoleModels.Branch"><code>SoleModels.Branch</code></a></li><li><a href="../autodocs/#SoleModels.ConstantModel"><code>SoleModels.ConstantModel</code></a></li><li><a href="../autodocs/#SoleModels.DecisionEnsemble"><code>SoleModels.DecisionEnsemble</code></a></li><li><a href="../autodocs/#SoleModels.DecisionForest"><code>SoleModels.DecisionForest</code></a></li><li><a href="../autodocs/#SoleModels.DecisionList"><code>SoleModels.DecisionList</code></a></li><li><a href="../autodocs/#SoleModels.DecisionSet"><code>SoleModels.DecisionSet</code></a></li><li><a href="../autodocs/#SoleModels.DecisionTree"><code>SoleModels.DecisionTree</code></a></li><li><a href="../autodocs/#SoleModels.DecisionXGBoost"><code>SoleModels.DecisionXGBoost</code></a></li><li><a href="../autodocs/#SoleModels.FunctionModel"><code>SoleModels.FunctionModel</code></a></li><li><a href="../autodocs/#SoleModels.LeafModel"><code>SoleModels.LeafModel</code></a></li><li><a href="../autodocs/#SoleModels.MixedModel"><code>SoleModels.MixedModel</code></a></li><li><a href="../autodocs/#SoleModels.PlainRuleExtractor"><code>SoleModels.PlainRuleExtractor</code></a></li><li><a href="../autodocs/#SoleModels.Rule"><code>SoleModels.Rule</code></a></li><li><a href="../autodocs/#SoleModels.RuleExtractor"><code>SoleModels.RuleExtractor</code></a></li><li><a href="../autodocs/#SoleLogics.atoms-Tuple{AbstractModel}"><code>SoleLogics.atoms</code></a></li><li><a href="../autodocs/#SoleLogics.connectives-Tuple{AbstractModel}"><code>SoleLogics.connectives</code></a></li><li><a href="../autodocs/#SoleLogics.height-Tuple{DecisionEnsemble}"><code>SoleLogics.height</code></a></li><li><a href="../autodocs/#SoleLogics.height-Tuple{DecisionTree}"><code>SoleLogics.height</code></a></li><li><a href="../autodocs/#SoleLogics.height-Tuple{DecisionXGBoost}"><code>SoleLogics.height</code></a></li><li><a href="../autodocs/#SoleLogics.natoms-Tuple{AbstractModel}"><code>SoleLogics.natoms</code></a></li><li><a href="../autodocs/#SoleLogics.nconnectives-Tuple{AbstractModel}"><code>SoleLogics.nconnectives</code></a></li><li><a href="../autodocs/#SoleLogics.nleaves-Tuple{DecisionEnsemble}"><code>SoleLogics.nleaves</code></a></li><li><a href="../autodocs/#SoleLogics.nleaves-Tuple{DecisionTree}"><code>SoleLogics.nleaves</code></a></li><li><a href="../autodocs/#SoleModels.antecedent-Tuple{Rule}"><code>SoleModels.antecedent</code></a></li><li><a href="../autodocs/#SoleModels.apply-Tuple{AbstractModel, SoleLogics.AbstractInterpretation}"><code>SoleModels.apply</code></a></li><li><a href="../autodocs/#SoleModels.checkantecedent"><code>SoleModels.checkantecedent</code></a></li><li><a href="../autodocs/#SoleModels.consequent-Tuple{Rule}"><code>SoleModels.consequent</code></a></li><li><a href="../autodocs/#SoleModels.defaultconsequent-Tuple{DecisionList}"><code>SoleModels.defaultconsequent</code></a></li><li><a href="../autodocs/#SoleModels.displaymodel-Tuple{AbstractModel}"><code>SoleModels.displaymodel</code></a></li><li><a href="../autodocs/#SoleModels.evaluaterule-Union{Tuple{L}, Tuple{ClassificationRule{L}, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractString, Real, Symbol, CategoricalArrays.CategoricalValue}}}} where L&lt;:Union{AbstractString, Symbol, CategoricalArrays.CategoricalValue}"><code>SoleModels.evaluaterule</code></a></li><li><a href="../autodocs/#SoleModels.evaluaterule-Tuple{Rule, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractString, Real, Symbol, CategoricalArrays.CategoricalValue}}}"><code>SoleModels.evaluaterule</code></a></li><li><a href="../autodocs/#SoleModels.extractrules-Tuple{SoleModels.RuleExtractor, Any, Vararg{Any}}"><code>SoleModels.extractrules</code></a></li><li><a href="../autodocs/#SoleModels.f-Tuple{FunctionModel}"><code>SoleModels.f</code></a></li><li><a href="../autodocs/#SoleModels.hasinfo-Tuple{AbstractModel, Any}"><code>SoleModels.hasinfo</code></a></li><li><a href="../autodocs/#SoleModels.haslistrules-Tuple{Any}"><code>SoleModels.haslistrules</code></a></li><li><a href="../autodocs/#SoleModels.immediatesubmodels-Union{Tuple{AbstractModel{O}}, Tuple{O}} where O"><code>SoleModels.immediatesubmodels</code></a></li><li><a href="../autodocs/#SoleModels.info-Tuple{AbstractModel}"><code>SoleModels.info</code></a></li><li><a href="../autodocs/#SoleModels.info!-Tuple{AbstractModel, Any}"><code>SoleModels.info!</code></a></li><li><a href="../autodocs/#SoleModels.iscomplete-Tuple{AbstractModel}"><code>SoleModels.iscomplete</code></a></li><li><a href="../autodocs/#SoleModels.isexact-Tuple{SoleModels.RuleExtractor}"><code>SoleModels.isexact</code></a></li><li><a href="../autodocs/#SoleModels.issymbolicmodel-Tuple{Any}"><code>SoleModels.issymbolicmodel</code></a></li><li><a href="../autodocs/#SoleModels.joinrules"><code>SoleModels.joinrules</code></a></li><li><a href="../autodocs/#SoleModels.listimmediaterules-Tuple{AbstractModel}"><code>SoleModels.listimmediaterules</code></a></li><li><a href="../autodocs/#SoleModels.listrules-Tuple{Any}"><code>SoleModels.listrules</code></a></li><li><a href="../autodocs/#SoleModels.negconsequent-Tuple{Branch}"><code>SoleModels.negconsequent</code></a></li><li><a href="../autodocs/#SoleModels.nimmediatesubmodels-Tuple{AbstractModel}"><code>SoleModels.nimmediatesubmodels</code></a></li><li><a href="../autodocs/#SoleModels.nnodes-Tuple{DecisionEnsemble}"><code>SoleModels.nnodes</code></a></li><li><a href="../autodocs/#SoleModels.nnodes-Tuple{DecisionTree}"><code>SoleModels.nnodes</code></a></li><li><a href="../autodocs/#SoleModels.nsyntaxleaves-Tuple{AbstractModel}"><code>SoleModels.nsyntaxleaves</code></a></li><li><a href="../autodocs/#SoleModels.ntrees-Tuple{DecisionForest}"><code>SoleModels.ntrees</code></a></li><li><a href="../autodocs/#SoleModels.outcome-Tuple{ConstantModel}"><code>SoleModels.outcome</code></a></li><li><a href="../autodocs/#SoleModels.outcometype-Union{Tuple{Type{&lt;:AbstractModel{O}}}, Tuple{O}} where O"><code>SoleModels.outcometype</code></a></li><li><a href="../autodocs/#SoleModels.outputtype-Tuple{AbstractModel}"><code>SoleModels.outputtype</code></a></li><li><a href="../autodocs/#SoleModels.parse_orange_decision_list"><code>SoleModels.parse_orange_decision_list</code></a></li><li><a href="../autodocs/#SoleModels.posconsequent-Tuple{Branch}"><code>SoleModels.posconsequent</code></a></li><li><a href="../autodocs/#SoleModels.printmodel-Tuple{AbstractModel}"><code>SoleModels.printmodel</code></a></li><li><a href="../autodocs/#SoleModels.readmetrics-Union{Tuple{LeafModel{L}}, Tuple{L}} where L&lt;:Union{AbstractString, Real, Symbol, CategoricalArrays.CategoricalValue}"><code>SoleModels.readmetrics</code></a></li><li><a href="../autodocs/#SoleModels.root-Tuple{MixedModel}"><code>SoleModels.root</code></a></li><li><a href="../autodocs/#SoleModels.root-Tuple{DecisionTree}"><code>SoleModels.root</code></a></li><li><a href="../autodocs/#SoleModels.rulebase-Tuple{DecisionList}"><code>SoleModels.rulebase</code></a></li><li><a href="../autodocs/#SoleModels.rulemetrics-Tuple{Rule, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractString, Real, Symbol, CategoricalArrays.CategoricalValue}}}"><code>SoleModels.rulemetrics</code></a></li><li><a href="../autodocs/#SoleModels.solemodel"><code>SoleModels.solemodel</code></a></li><li><a href="../autodocs/#SoleModels.submodels-Tuple{AbstractModel}"><code>SoleModels.submodels</code></a></li><li><a href="../autodocs/#SoleModels.syntaxleaves-Tuple{AbstractModel}"><code>SoleModels.syntaxleaves</code></a></li><li><a href="../autodocs/#SoleModels.trees-Tuple{DecisionForest}"><code>SoleModels.trees</code></a></li><li><a href="../autodocs/#SoleModels.wrap-Tuple{Any, Type{&lt;:AbstractModel}}"><code>SoleModels.wrap</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.Atom-logic" href="#SoleLogics.Atom-logic"><code>SoleLogics.Atom</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Atom{V} &lt;: AbstractAtom
    value::V
end</code></pre><p>Simplest atom implementation, wrapping a <code>value</code>.</p><p>See also <a href="@ref"><code>AbstractAtom</code></a>, <a href="@ref"><code>value</code></a>, <a href="#SoleLogics.check-logic"><code>check</code></a>, <a href="@ref"><code>SyntaxToken</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/utils/syntactical.jl#L35-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.CONJUNCTION-logic" href="#SoleLogics.CONJUNCTION-logic"><code>SoleLogics.CONJUNCTION</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const CONJUNCTION = NamedConnective{:∧}()
const ∧ = CONJUNCTION
arity(::typeof(∧)) = 2</code></pre><p>Logical conjunction. It can be typed by <code>\wedge&lt;tab&gt;</code>.</p><p>See also <a href="@ref"><code>NamedConnective</code></a>, <a href="@ref"><code>Connective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/utils/base-logic.jl#L32-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.DISJUNCTION-logic" href="#SoleLogics.DISJUNCTION-logic"><code>SoleLogics.DISJUNCTION</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const DISJUNCTION = NamedConnective{:∨}()
const ∨ = DISJUNCTION
arity(::typeof(∨)) = 2</code></pre><p>Logical disjunction. It can be typed by <code>\vee&lt;tab&gt;</code>.</p><p>See also <a href="@ref"><code>NamedConnective</code></a>, <a href="@ref"><code>Connective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/utils/base-logic.jl#L48-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.Formula-logic" href="#SoleLogics.Formula-logic"><code>SoleLogics.Formula</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type Formula &lt;: Syntactical end</code></pre><p>Abstract type for logical formulas. Examples of <code>Formula</code>s are <code>SyntaxLeaf</code>s (for example, <code>Atom</code>s and <code>Truth</code> values), <code>SyntaxStructure</code>s (for example, <code>SyntaxTree</code>s and <code>LeftmostLinearForm</code>s) and <code>TruthTable</code>s ( enriched representation, which associates a syntactic structure with additional <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a> structures, which can save computational time upon <a href="https://en.wikipedia.org/wiki/Model_checking">model checking</a>).</p><p>Any formula can be converted into its <a href="@ref"><code>SyntaxTree</code></a> representation via <a href="@ref"><code>tree</code></a>; its <a href="../autodocs/#SoleLogics.height-Tuple{DecisionEnsemble}"><code>height</code></a> can be computed, and it can be queried for its syntax <a href="@ref"><code>tokens</code></a>, <a href="../autodocs/#SoleLogics.atoms-Tuple{AbstractModel}"><code>atoms</code></a>, etc... It can be parsed from its <a href="#SoleLogics.syntaxstring-logic"><code>syntaxstring</code></a> representation via <a href="@ref"><code>parseformula</code></a>.</p><p><strong>Interface</strong></p><ul><li><code>tree(φ::Formula)::SyntaxTree</code></li><li><code>composeformulas(c::Connective, φs::NTuple{N,F})::F where {N,F&lt;:Formula}</code></li><li>See also <a href="@ref"><code>Syntactical</code></a></li></ul><p><strong>Utility functions (requiring a walk of the tree)</strong></p><ul><li><p><code>Base.in(tok::SyntaxToken, φ::Formula)::Bool</code></p></li><li><p><code>height(φ::Formula)::Int</code></p></li><li><p><code>tokens(φ::Formula)::AbstractVector{&lt;:SyntaxToken}</code></p></li><li><p><code>atoms(φ::Formula)::AbstractVector{&lt;:AbstractAtom}</code></p></li><li><p><code>truths(φ::Formula)::AbstractVector{&lt;:Truth}</code></p></li><li><p><code>leaves(φ::Formula)::AbstractVector{&lt;:SyntaxLeaf}</code></p></li><li><p><code>connectives(φ::Formula)::AbstractVector{&lt;:Connective}</code></p></li><li><p><code>operators(φ::Formula)::AbstractVector{&lt;:Operator}</code></p></li><li><p><code>ntokens(φ::Formula)::Int</code></p></li><li><p><code>natoms(φ::Formula)::Int</code></p></li><li><p><code>ntruths(φ::Formula)::Int</code></p></li><li><p><code>nleaves(φ::Formula)::Int</code></p></li><li><p><code>nconnectives(φ::Formula)::Int</code></p></li><li><p><code>noperators(φ::Formula)::Int</code></p></li></ul><p>See also <a href="@ref"><code>tree</code></a>, <a href="@ref"><code>SyntaxStructure</code></a>, <a href="@ref"><code>SyntaxLeaf</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/types/syntactical.jl#L151-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.syntaxstring-logic" href="#SoleLogics.syntaxstring-logic"><code>SoleLogics.syntaxstring</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">syntaxstring(s::Syntactical; kwargs...)::String</code></pre><p>Return the string representation of any syntactic object (e.g., <code>Formula</code>, <code>SyntaxTree</code>, <code>SyntaxToken</code>, <code>Atom</code>, <code>Truth</code>, etc). Note that this representation may introduce redundant parentheses. <code>kwargs</code> can be used to specify how to display syntax tokens/trees under some specific conditions.</p><p>The following <code>kwargs</code> are currently supported:</p><ul><li><code>function_notation = false::Bool</code>: when set to <code>true</code>, it forces the use of  function notation for binary operators  (see <a href="https://en.wikipedia.org/wiki/Infix_notation">here</a>).</li><li><code>remove_redundant_parentheses = true::Bool</code>: when set to <code>false</code>, it prints a syntaxstring  where each syntactical element is wrapped in parentheses.</li><li><code>parenthesize_atoms = !remove_redundant_parentheses::Bool</code>: when set to <code>true</code>,  it forces the atoms (which are the leaves of a formula&#39;s tree structure) to be  wrapped in parentheses.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(parseformula(&quot;p∧q∧r∧s∧t&quot;))
&quot;p ∧ q ∧ r ∧ s ∧ t&quot;

julia&gt; syntaxstring(parseformula(&quot;p∧q∧r∧s∧t&quot;), function_notation=true)
&quot;∧(∧(∧(∧(p, q), r), s), t)&quot;

julia&gt; syntaxstring(parseformula(&quot;p∧q∧r∧s∧t&quot;), remove_redundant_parentheses=false)
&quot;((((p) ∧ (q)) ∧ (r)) ∧ (s)) ∧ (t)&quot;

julia&gt; syntaxstring(parseformula(&quot;p∧q∧r∧s∧t&quot;), remove_redundant_parentheses=true, parenthesize_atoms=true)
&quot;(p) ∧ (q) ∧ (r) ∧ (s) ∧ (t)&quot;

julia&gt; syntaxstring(parseformula(&quot;◊((p∧s)→q)&quot;))
&quot;◊((p ∧ s) → q)&quot;

julia&gt; syntaxstring(parseformula(&quot;◊((p∧s)→q)&quot;); function_notation = true)
&quot;◊(→(∧(p, s), q))&quot;</code></pre><p>See also <a href="@ref"><code>parseformula</code></a>, <a href="@ref"><code>SyntaxBranch</code></a>, <a href="@ref"><code>SyntaxToken</code></a>.</p><p><strong>Implementation</strong></p><p>In the case of a syntax tree, <code>syntaxstring</code> is a recursive function that calls itself on the syntax children of each node. For a correct functioning, the <code>syntaxstring</code> must be defined (including the <code>kwargs...</code> part!) for every newly defined <code>SyntaxToken</code> (e.g., <code>SyntaxLeaf</code>s, that is, <code>Atom</code>s and <code>Truth</code> values, and <code>Operator</code>s), in a way that it produces a <em>unique</em> string representation, since <code>Base.hash</code> and <code>Base.isequal</code>, at least for <code>SyntaxTree</code>s, rely on it.</p><p>In particular, for the case of <code>Atom</code>s, the function calls itself on the wrapped value:</p><pre><code class="nohighlight hljs">syntaxstring(a::Atom; kwargs...) = syntaxstring(value(a); kwargs...)</code></pre><p>The <code>syntaxstring</code> for any value defaults to its <code>string</code> representation, but it can be defined by defining the appropriate <code>syntaxstring</code> method.</p><div class="admonition is-warning" id="Warning-9fb92bec4b0eab28"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-9fb92bec4b0eab28" title="Permalink"></a></header><div class="admonition-body"><p>The <code>syntaxstring</code> for syntax tokens (e.g., atoms, operators) should not be prefixed/suffixed by whitespaces, as this may cause ambiguities upon <em>parsing</em>. For similar reasons, <code>syntaxstring</code>s should not contain parentheses (<code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>), and, when parsing in function notation, commas (<code>&#39;,&#39;</code>).</p></div></div><p>See also <a href="@ref"><code>SyntaxLeaf</code></a>, <a href="@ref"><code>Operator</code></a>, <a href="@ref"><code>parseformula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/types/syntactical.jl#L37-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractAlphabet-logic" href="#SoleLogics.AbstractAlphabet-logic"><code>SoleLogics.AbstractAlphabet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractAlphabet{V} end</code></pre><p>Abstract type for representing an alphabet of atoms with values of type <code>V</code>. An alphabet (or <em>propositional alphabet</em>) is a set of atoms (assumed to be <a href="https://en.wikipedia.org/wiki/Countable_set">countable</a>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Atom(1) in ExplicitAlphabet(Atom.(1:10))
true

julia&gt; Atom(1) in ExplicitAlphabet(1:10)
true

julia&gt; Atom(1) in AlphabetOfAny{String}()
false

julia&gt; Atom(&quot;mystring&quot;) in AlphabetOfAny{String}()
true

julia&gt; &quot;mystring&quot; in AlphabetOfAny{String}()
┌ Warning: Please, use Base.in(Atom(mystring), alphabet::AlphabetOfAny{String}) instead of Base.in(mystring, alphabet::AlphabetOfAny{String})
└ @ SoleLogics ...
true</code></pre><p><strong>Interface</strong></p><ul><li><code>atoms(a::AbstractAlphabet)::AbstractVector</code></li><li><code>Base.isfinite(::Type{&lt;:AbstractAlphabet})::Bool</code></li><li><code>randatom(rng::Union{Random.AbstractRNG, Integer}, a::AbstractAlphabet, args...; kwargs...)::AbstractAtom</code></li></ul><p><strong>Utility functions</strong></p><ul><li><code>natoms(a::AbstractAlphabet)::Bool</code></li><li><code>Base.in(p::AbstractAtom, a::AbstractAlphabet)::Bool</code></li><li><code>Base.eltype(a::AbstractAlphabet)</code></li><li><code>randatom(a::AbstractAlphabet, args...; kwargs...)::AbstractAtom</code></li><li><code>atomstype(a::AbstractAlphabet)</code></li><li><code>valuetype(a::AbstractAlphabet)</code></li></ul><p><strong>Implementation</strong></p><p>When implementing a new alphabet type <code>MyAlphabet</code>, you should provide a method for establishing whether an atom belongs to it or not; while, in general, this method should be:</p><pre><code class="nohighlight hljs">function Base.in(p::AbstractAtom, a::MyAlphabet)::Bool</code></pre><p>in the case of <em>finite</em> alphabets, it suffices to define a method:</p><pre><code class="nohighlight hljs">function atoms(a::AbstractAlphabet)::AbstractVector{atomstype(a)}</code></pre><p>By default, an alphabet is considered finite:</p><pre><code class="nohighlight hljs">Base.isfinite(::Type{&lt;:AbstractAlphabet}) = true
Base.isfinite(a::AbstractAlphabet) = Base.isfinite(typeof(a))
Base.in(p::AbstractAtom, a::AbstractAlphabet) = Base.isfinite(a) ? Base.in(p, atoms(a)) : error(...)</code></pre><p>See also <a href="@ref"><code>AbstractGrammar</code></a>, <a href="@ref"><code>AlphabetOfAny</code></a>, <a href="@ref"><code>AbstractAtom</code></a>, <a href="@ref"><code>ExplicitAlphabet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/types/logic.jl#L10-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractInterpretation-logic" href="#SoleLogics.AbstractInterpretation-logic"><code>SoleLogics.AbstractInterpretation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractInterpretation end</code></pre><p>Abstract type for representing a <a href="https://en.wikipedia.org/wiki/Interpretation_(logic)">logical interpretation</a>. In the case of <a href="https://simple.wikipedia.org/wiki/Propositional_logic">propositional logic</a>, is essentially a map <em>atom → truth value</em>.</p><p>Properties expressed via logical formulas can be <code>check</code>ed on logical interpretations.</p><p><strong>Interface</strong></p><ul><li><code>valuetype(i::AbstractInterpretation)</code></li><li><code>truthtype(i::AbstractInterpretation)</code></li><li><code>interpret(φ::Formula, i::AbstractInterpretation, args...; kwargs...)::Formula</code></li></ul><p><strong>Utility functions</strong></p><ul><li><code>check(φ::Formula, i::AbstractInterpretation, args...; kwargs...)::Bool</code></li></ul><p>See also <a href="#SoleLogics.check-logic"><code>check</code></a>, <a href="@ref"><code>AbstractAssignment</code></a>, <a href="#SoleLogics.AbstractKripkeStructure-logic"><code>AbstractKripkeStructure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/types/interpretation.jl#L6-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractInterpretationSet-logic" href="#SoleLogics.AbstractInterpretationSet-logic"><code>SoleLogics.AbstractInterpretationSet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractInterpretationSet &lt;: AbstractDataset end</code></pre><p>Abstract type for ordered sets of interpretations. A set of interpretations, also referred to as a <em>dataset</em> in this context, is a collection of <em>instances</em>, each of which is an interpretation, and is identified by an index i<em>instance::Integer. These structures are especially useful when performing [model checking](https://en.wikipedia.org/wiki/Model</em>checking).</p><p><strong>Interface</strong></p><ul><li><a href="@ref"><code>interpretationtype(S)</code></a></li><li><a href="@ref"><code>alphabet(s)</code></a></li><li><a href="@ref"><code>getinstance(s)</code></a></li><li><a href="@ref"><code>concatdatasets(ss...)</code></a></li><li><a href="@ref"><code>instances(s, idxs, return_view; kwargs...)</code></a></li><li><a href="@ref"><code>ninstances(s)</code></a></li></ul><p><strong>Utility Functions</strong></p><ul><li><a href="@ref"><code>valuetype(s)</code></a></li><li><a href="@ref"><code>truthtype(s)</code></a></li><li><a href="@ref"><code>slicedataset(s, idxs; kwargs...)</code></a></li><li><a href="@ref"><code>eachinstance(s)</code></a></li></ul><p><strong>Utility Functions (with more-than-propositional logics)</strong></p><ul><li><a href="@ref"><code>worldtype(s)</code></a></li><li><a href="@ref"><code>frametype(s)</code></a></li><li><a href="@ref"><code>frame(s, i_instance)</code></a></li><li><a href="#SoleLogics.accessibles-logic"><code>accessibles(s, i_instance, args...)</code></a></li><li><a href="@ref"><code>allworlds(s, i_instance, args...)</code></a></li><li><a href="@ref"><code>nworlds(s, i_instance)</code></a></li></ul><p>See also <a href="@ref"><code>InterpretationVector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/types/interpretation-sets.jl#L5-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.check-logic" href="#SoleLogics.check-logic"><code>SoleLogics.check</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check(
    φ::SoleLogics.SyntaxTree,
    i::SoleLogics.LogicalInstance{&lt;:AbstractModalLogiset{W,&lt;:U}},
    w::Union{Nothing,AnyWorld,&lt;:AbstractWorld} = nothing;
    kwargs...
)::Bool</code></pre><p>Check whether a formula <code>φ</code> holds for a given instance <code>i_instance</code> of a logiset <code>X</code>, on a world <code>w</code>. Note that the world can be elided for grounded formulas (see <a href="@ref"><code>isgrounded</code></a>).</p><p>This implementation recursively evaluates the subformulas of <code>φ</code> and use memoization to store the results using Emerson-Clarke algorithm. The memoization structure is either the one stored in <code>X</code> itself (if <code>X</code> supports memoization) or a structure passed as the <code>use_memo</code> argument. If <code>X</code> supports onestep memoization, then it will be used for specific diamond formulas, up to an height equal to a keyword argument <code>memo_max_height</code>.</p><p><strong>Arguments</strong></p><ul><li><code>φ::SoleLogics.SyntaxTree</code>: the formula to check.</li><li><code>i::SoleLogics.LogicalInstance{&lt;:AbstractModalLogiset{W,&lt;:U}}</code>: the instance of the logiset to check in.</li><li><code>w::Union{Nothing,AnyWorld,&lt;:AbstractWorld} = nothing</code>: the world to check in. If <code>nothing</code>, the method checks in all worlds of the instance.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>use_memo::Union{Nothing,AbstractMemoset{&lt;:AbstractWorld},AbstractVector{&lt;:AbstractDict{&lt;:FT,&lt;:AbstractWorlds}}} = nothing</code>: the memoization structure to use. If <code>nothing</code>, the method uses the one stored in <code>X</code> if <code>X</code> supports memoization. If <code>AbstractMemoset</code>, the method uses the <code>i_instance</code>-th element of the memoization structure. If <code>AbstractVector</code>, the method uses the <code>i_instance</code>-th element of the vector.</li><li><code>perform_normalization::Bool = true</code>: whether to normalize the formula before checking it.</li><li><code>memo_max_height::Union{Nothing,Int} = nothing</code>: the maximum height up to which onestep memoization should be used. If <code>nothing</code>, the method does not use onestep memoization.</li><li><code>onestep_memoset_is_complete = false</code>: whether the onestep memoization structure is complete (i.e. it contains all possible values of the metaconditions in the structure).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/v0.16.3/src/check.jl#L31-L57">source</a></section><section><div><pre><code class="language-julia hljs">check(
    φ::Formula,
    i::AbstractInterpretation,
    args...;
    kwargs...
)::Bool</code></pre><p>Check a formula on a logical interpretation (or model), returning <code>true</code> if the truth value for the formula <code>istop</code>. This process is referred to as (finite) <a href="https://en.wikipedia.org/wiki/Model_checking">model checking</a>, and there are many algorithms for it, typically depending on the complexity of the logic.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @atoms String p q
2-element Vector{Atom{String}}:
 Atom{String}(&quot;p&quot;)
 Atom{String}(&quot;q&quot;)

julia&gt; td = TruthDict([p =&gt; TOP, q =&gt; BOT])
TruthDict with values:
┌────────┬────────┐
│      q │      p │
│ String │ String │
├────────┼────────┤
│      ⊥ │      ⊤ │
└────────┴────────┘

julia&gt; check(CONJUNCTION(p,q), td)
false</code></pre><p>See also <a href="@ref"><code>interpret</code></a>, <a href="#SoleLogics.Formula-logic"><code>Formula</code></a>, <a href="#SoleLogics.AbstractInterpretation-logic"><code>AbstractInterpretation</code></a>, <a href="@ref"><code>TruthDict</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/types/interpretation.jl#L110-L146">source</a></section><section><div><pre><code class="language-julia hljs">check(φ::Formula, i::Union{AbstractDict, AbstractVector}, args...)</code></pre><p>Takes a <a href="#SoleLogics.Formula-logic"><code>Formula</code></a> as input and returns its truth value in relation to the dictionary  or vector passed. We let any <code>AbstractDict</code> and <code>AbstractVector</code> be used as an interpretation  when model checking.</p><p>See also <a href="#SoleLogics.Formula-logic"><code>Formula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/utils/propositional-logic.jl#L352-L360">source</a></section><section><div><pre><code class="language-julia hljs">check(a::Atom, i::AbstractDict)</code></pre><p>Returns the Boolean value corresponding to the atom passed as parameter.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; check(Atom(1), Dict([1 =&gt; ⊤, 2 =&gt; ⊥]))
true

julia&gt; check(Atom(3), Dict([1 =&gt; ⊤, 2 =&gt; ⊥]))
false</code></pre><p>See also <a href="#SoleLogics.Atom-logic"><code>Atom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/utils/propositional-logic.jl#L421-L437">source</a></section><section><div><pre><code class="language-julia hljs">check(a::Atom, i::AbstractVector)</code></pre><p>Returns a truth value indicating whether or not that <a href="#SoleLogics.Atom-logic"><code>Atom</code></a>  is contained in the passed vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; check(Atom(1), [1,2,4])
true

julia&gt; check(Atom(5), [2,3,4])
false</code></pre><p>See also <a href="#SoleLogics.Atom-logic"><code>Atom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/utils/propositional-logic.jl#L478-L495">source</a></section><section><div><pre><code class="language-julia hljs">function check(
    φ::SyntaxTree,
    i::AbstractKripkeStructure,
    w::Union{Nothing,AnyWorld,&lt;:AbstractWorld} = nothing;
    use_memo::Union{Nothing,AbstractDict{&lt;:Formula,&lt;:Vector{&lt;:AbstractWorld}}} = nothing,
    perform_normalization::Bool = true,
    memo_max_height::Union{Nothing,Int} = nothing,
)::Bool</code></pre><p>Check a formula on a specific word in a <a href="@ref"><code>KripkeStructure</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs, Random

julia&gt; @atoms String p q
2-element Vector{Atom{String}}:
 Atom{String}(&quot;p&quot;)
 Atom{String}(&quot;q&quot;)

julia&gt; fmodal = randformula(Random.MersenneTwister(14), 3, [p,q], SoleLogics.BASE_MODAL_CONNECTIVES)
¬□(p ∨ q)

# A special graph, called Kripke Frame, is created.
# Nodes are called worlds, and the edges are relations between worlds.
julia&gt; worlds = SoleLogics.World.(1:5) # 5 worlds are created, numerated from 1 to 5

julia&gt; edges = Edge.([(1,2), (1,3), (2,4), (3,4), (3,5)])

julia&gt; kframe = SoleLogics.ExplicitCrispUniModalFrame(worlds, Graphs.SimpleDiGraph(edges))

# A valuation function establishes which fact are true on each world
julia&gt; valuation = Dict([
    worlds[1] =&gt; TruthDict([p =&gt; true, q =&gt; false]),
    worlds[2] =&gt; TruthDict([p =&gt; true, q =&gt; true]),
    worlds[3] =&gt; TruthDict([p =&gt; true, q =&gt; false]),
    worlds[4] =&gt; TruthDict([p =&gt; false, q =&gt; false]),
    worlds[5] =&gt; TruthDict([p =&gt; false, q =&gt; true]),
 ])

# Kripke Frame and valuation function are merged in a Kripke Structure
julia&gt; kstruct = KripkeStructure(kframe, valuation)

julia&gt; [w =&gt; check(fmodal, kstruct, w) for w in worlds]
5-element Vector{Pair{SoleLogics.World{Int64}, Bool}}:
 SoleLogics.World{Int64}(1) =&gt; 0
 SoleLogics.World{Int64}(2) =&gt; 1
 SoleLogics.World{Int64}(3) =&gt; 1
 SoleLogics.World{Int64}(4) =&gt; 0
 SoleLogics.World{Int64}(5) =&gt; 0</code></pre><p>See also <a href="@ref"><code>SyntaxTree</code></a>, <a href="#SoleLogics.AbstractWorld-logic"><code>AbstractWorld</code></a>, <a href="@ref"><code>KripkeStructure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/utils/modal-logic.jl#L282-L336">source</a></section><section><div><pre><code class="language-julia hljs">check(
    φ::Formula,
    s::AbstractInterpretationSet,
    i_instance::Integer,
    args...;
    kwargs...
)::Bool</code></pre><p>Check a formula on the <span>$i$</span>-th instance of an <a href="#SoleLogics.AbstractInterpretationSet-logic"><code>AbstractInterpretationSet</code></a>.</p><p>See also <a href="#SoleLogics.AbstractInterpretationSet-logic"><code>AbstractInterpretationSet</code></a>, <a href="#SoleLogics.Formula-logic"><code>Formula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/utils/interpretation-sets.jl#L122-L135">source</a></section><section><div><pre><code class="language-julia hljs">check(
    φ::Formula,
    s::AbstractInterpretationSet,
    args...;
    kwargs...
)::Vector{Bool}</code></pre><p>Check a formula on all instances of an <a href="#SoleLogics.AbstractInterpretationSet-logic"><code>AbstractInterpretationSet</code></a>.</p><p>See also <a href="#SoleLogics.AbstractInterpretationSet-logic"><code>AbstractInterpretationSet</code></a>, <a href="#SoleLogics.Formula-logic"><code>Formula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/utils/interpretation-sets.jl#L182-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractWorld-logic" href="#SoleLogics.AbstractWorld-logic"><code>SoleLogics.AbstractWorld</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractWorld end</code></pre><p>Abstract type for the nodes of an annotated accessibility graph (Kripke structure). This is used, for example, in modal logic, where the truth of formulas is relativized to <em>worlds</em>, that is, nodes of a graph.</p><p><strong>Implementing</strong></p><p>When implementing a new world type, the logical semantics should be defined via <code>accessibles</code> methods; refer to the help for <code>accessibles</code>.</p><p>See also <a href="#SoleLogics.AbstractKripkeStructure-logic"><code>AbstractKripkeStructure</code></a>, <a href="#SoleLogics.AbstractFrame-logic"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/types/modal-logic.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.GeometricalWorld-logic" href="#SoleLogics.GeometricalWorld-logic"><code>SoleLogics.GeometricalWorld</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type GeometricalWorld &lt;: AbstractWorld end</code></pre><p>Abstract type for worlds with a geometrical interpretation.</p><p>See also <a href="@ref"><code>Point</code></a>, <a href="#SoleLogics.Interval-logic"><code>Interval</code></a>, <a href="#SoleLogics.Interval2D-logic"><code>Interval2D</code></a>, <a href="#SoleLogics.AbstractWorld-logic"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/types/frames/worlds/geometrical-world.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.Interval-logic" href="#SoleLogics.Interval-logic"><code>SoleLogics.Interval</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Interval{T&lt;:Real} &lt;: GeometricalWorld
    x :: T
    y :: T
end</code></pre><p>An interval in a 1-dimensional space, with coordinates of type <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SoleLogics.goeswithdim(SoleLogics.Interval(1,2),1)
true

julia&gt; SoleLogics.goeswithdim(SoleLogics.Interval(1,2),2)
false

julia&gt; collect(accessibles(SoleLogics.FullDimensionalFrame(5), Interval(1,2), SoleLogics.IA_L))
6-element Vector{Interval{Int64}}:
 (3−4)
 (3−5)
 (4−5)
 (3−6)
 (4−6)
 (5−6)

</code></pre><p>See also <a href="@ref"><code>goeswithdim</code></a>, <a href="#SoleLogics.accessibles-logic"><code>accessibles</code></a>, <a href="@ref"><code>FullDimensionalFrame</code></a>, <a href="@ref"><code>Point</code></a>, <a href="#SoleLogics.Interval2D-logic"><code>Interval2D</code></a>, <a href="#SoleLogics.GeometricalWorld-logic"><code>GeometricalWorld</code></a>, <a href="#SoleLogics.AbstractWorld-logic"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/utils/frames/worlds/geometrical-worlds.jl#L87-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.Interval2D-logic" href="#SoleLogics.Interval2D-logic"><code>SoleLogics.Interval2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Interval2D{T&lt;:Real} &lt;: GeometricalWorld
    x :: Interval{T}
    y :: Interval{T}
end</code></pre><p>A orthogonal rectangle in a 2-dimensional space, with coordinates of type <code>T</code>. This is the 2-dimensional <code>Interval</code> counterpart, that is, the combination of two orthogonal <code>Interval</code>s.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),1)
false

julia&gt; SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),2)
true

julia&gt; collect(accessibles(SoleLogics.FullDimensionalFrame(5,5), Interval2D((2,3),(2,4)), SoleLogics.IA_LL))
3-element Vector{Interval2D{Int64}}:
 ((4−5)×(5−6))
 ((4−6)×(5−6))
 ((5−6)×(5−6))
</code></pre><p>See also <a href="@ref"><code>goeswithdim</code></a>, <a href="#SoleLogics.accessibles-logic"><code>accessibles</code></a>, <a href="@ref"><code>FullDimensionalFrame</code></a>, <a href="@ref"><code>Point</code></a>, <a href="#SoleLogics.Interval-logic"><code>Interval</code></a>, <a href="#SoleLogics.GeometricalWorld-logic"><code>GeometricalWorld</code></a>, <a href="#SoleLogics.AbstractWorld-logic"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/utils/frames/worlds/geometrical-worlds.jl#L148-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractRelation-logic" href="#SoleLogics.AbstractRelation-logic"><code>SoleLogics.AbstractRelation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractRelation end</code></pre><p>Abstract type for the relations of a multi-modal annotated accessibility graph (Kripke structure). Two noteworthy relations are <code>identityrel</code> and <code>globalrel</code>, which access the current world and all worlds, respectively.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fr = SoleLogics.FullDimensionalFrame((10,), Interval{Int});

julia&gt; Interval(8,11) in (accessibles(fr, Interval(2,5), IA_L))
true</code></pre><p><strong>Implementation</strong></p><p>When implementing a new relation type <code>R</code>, please provide the methods:</p><pre><code class="nohighlight hljs">arity(::R)::Int = ...
syntaxstring(::R; kwargs...)::String = ...</code></pre><p>If the relation is symmetric, please specify its converse relation <code>cr</code> with:</p><pre><code class="nohighlight hljs">hasconverse(::R) = true
converse(::R) = cr</code></pre><p>If the relation is many-to-one or one-to-one, please flag it with:</p><pre><code class="nohighlight hljs">istoone(::R) = true</code></pre><p>If the relation is reflexive or transitive, flag it with:</p><pre><code class="nohighlight hljs">isreflexive(::R) = true
istransitive(::R) = true</code></pre><p>Most importantly, the logical semantics for <code>R</code> should be defined via <code>accessibles</code> methods; refer to the help for <code>accessibles</code>.</p><p>See also <a href="@ref"><code>issymmetric</code></a>, <a href="@ref"><code>isreflexive</code></a>, <a href="@ref"><code>istransitive</code></a>, <a href="@ref"><code>isgrounding</code></a>, <a href="@ref"><code>arity</code></a>, <a href="#SoleLogics.syntaxstring-logic"><code>syntaxstring</code></a>, <a href="@ref"><code>converse</code></a>, <a href="@ref"><code>hasconverse</code></a>, <a href="@ref"><code>istoone</code></a>, <a href="@ref"><code>identityrel</code></a>, <a href="#SoleLogics.globalrel-logic"><code>globalrel</code></a>, <a href="#SoleLogics.accessibles-logic"><code>accessibles</code></a>, <a href="#SoleLogics.AbstractKripkeStructure-logic"><code>AbstractKripkeStructure</code></a>, <a href="#SoleLogics.AbstractFrame-logic"><code>AbstractFrame</code></a>, <a href="#SoleLogics.AbstractWorld-logic"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/types/modal-logic.jl#L106-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.globalrel-logic" href="#SoleLogics.globalrel-logic"><code>SoleLogics.globalrel</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GlobalRel &lt;: AbstractRelation end;
const globalrel  = GlobalRel();</code></pre><p>Singleton type for the global relation. This is a binary relation via which a world accesses every other world within the frame. The relation is also symmetric, reflexive and transitive.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(SoleLogics.globalrel)
&quot;G&quot;

julia&gt; SoleLogics.converse(globalrel)
GlobalRel()</code></pre><p>See also <a href="@ref"><code>identityrel</code></a>, <a href="#SoleLogics.AbstractRelation-logic"><code>AbstractRelation</code></a>, <a href="#SoleLogics.AbstractWorld-logic"><code>AbstractWorld</code></a>, <a href="#SoleLogics.AbstractFrame-logic"><code>AbstractFrame</code></a>. <a href="#SoleLogics.AbstractKripkeStructure-logic"><code>AbstractKripkeStructure</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/utils/modal-logic.jl#L142-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.IA_L-logic" href="#SoleLogics.IA_L-logic"><code>SoleLogics.IA_L</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="@ref"><code>IntervalRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/utils/frames/relations/IntervalAlgebra.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractFrame-logic" href="#SoleLogics.AbstractFrame-logic"><code>SoleLogics.AbstractFrame</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractFrame{W&lt;:AbstractWorld} end</code></pre><p>Abstract type for an accessibility graph (Kripke frame), that gives the topology to <a href="https://en.wikipedia.org/wiki/Kripke_structure_(model_checking)">Kripke structures</a>. A frame can be queried for its set of vertices (also called <em>worlds</em>, see <a href="@ref"><code>allworlds</code></a>), and it can be browsed via its accessibility relation(s) (see <a href="#SoleLogics.accessibles-logic"><code>accessibles</code></a>). Refer to <a href="@ref"><code>FullDimensionalFrame</code></a> as an example.</p><p>See also <a href="@ref"><code>truthtype</code></a>, , <a href="@ref"><code>allworlds</code></a>, <a href="@ref"><code>nworlds</code></a>, <a href="#SoleLogics.AbstractKripkeStructure-logic"><code>AbstractKripkeStructure</code></a>, <a href="#SoleLogics.AbstractWorld-logic"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/types/modal-logic.jl#L28-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractKripkeStructure-logic" href="#SoleLogics.AbstractKripkeStructure-logic"><code>SoleLogics.AbstractKripkeStructure</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractKripkeStructure &lt;: AbstractInterpretation end</code></pre><p>Abstract type for representing <a href="https://en.wikipedia.org/wiki/Kripke_structure_(model_checking)">Kripke structures</a>&#39;s. It comprehends a directed graph structure (Kripke frame), where nodes are referred to as <em>worlds</em>, and the binary relation between them is referred to as the <em>accessibility relation</em>. Additionally, each world is associated with a mapping from <code>Atom</code>s to <code>Truth</code> values.</p><p>See also <a href="@ref"><code>frame</code></a>, <a href="@ref"><code>worldtype</code></a>, <a href="#SoleLogics.accessibles-logic"><code>accessibles</code></a>, <a href="#SoleLogics.AbstractInterpretation-logic"><code>AbstractInterpretation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/types/modal-logic.jl#L373-L385">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.accessibles-logic" href="#SoleLogics.accessibles-logic"><code>SoleLogics.accessibles</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">accessibles(fr::AbstractUniModalFrame{W}, w::W)::Worlds{W} where {W&lt;:AbstractWorld}</code></pre><p>Return the worlds in frame <code>fr</code> that are accessible from world <code>w</code>.</p><p>See also <a href="#SoleLogics.AbstractWorld-logic"><code>AbstractWorld</code></a>, <a href="@ref"><code>AbstractUniModalFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/types/modal-logic.jl#L91-L97">source</a></section><section><div><pre><code class="language-julia hljs">accessibles(
    fr::AbstractMultiModalFrame{W},
    w::W,
    r::AbstractRelation
) where {W&lt;:AbstractWorld}</code></pre><p>Return the worlds in frame <code>fr</code> that are accessible from world <code>w</code> via relation <code>r</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fr = SoleLogics.FullDimensionalFrame((10,), Interval{Int});

julia&gt; typeof(accessibles(fr, Interval(2,5), IA_L))
Base.Generator{...}

julia&gt; typeof(accessibles(fr, globalrel))
Base.Generator{...}

julia&gt; @assert SoleLogics.nworlds(fr) == length(collect(accessibles(fr, globalrel)))

julia&gt; typeof(accessibles(fr, Interval(2,5), identityrel))
Vector{Interval{Int64}}

julia&gt; Interval(8,11) in collect(accessibles(fr, Interval(2,5), IA_L))
true</code></pre><p><strong>Implementation</strong></p><p>Since <code>accessibles</code> always returns an iterator to worlds of the same type <code>W</code>, the current implementation of <code>accessibles</code> for multi-modal frames delegates the enumeration to a lower level <code>_accessibles</code> function, which returns an iterator to parameter tuples that are, then, fed to the world constructor the using IterTools generators, as in:</p><pre><code class="nohighlight hljs">function accessibles(
    fr::AbstractMultiModalFrame{W},
    w::W,
    r::AbstractRelation,
) where {W&lt;:AbstractWorld}
    IterTools.imap(W, _accessibles(fr, w, r))
end</code></pre><p>As such, when defining new frames, worlds, and/or relations, one should provide new methods for <code>_accessibles</code>. For example:</p><pre><code class="nohighlight hljs">_accessibles(fr::Full1DFrame, w::Interval{&lt;:Integer}, ::_IA_A) = zip(Iterators.repeated(w.y), w.y+1:X(fr)+1)</code></pre><p>This pattern is generally convenient; it can, however, be bypassed, although this requires defining two additional methods in order to resolve dispatch ambiguities. When defining a new frame type <code>FR{W}</code>, one can resolve the ambiguities and define a custom <code>accessibles</code> method by providing these three methods:</p><pre><code class="nohighlight hljs"># access worlds through relation `r`
function accessibles(
    fr::FR{W},
    w::W,
    r::AbstractRelation,
) where {W&lt;:AbstractWorld}
    ...
end

# access current world
function accessibles(
    fr::FR{W},
    w::W,
    r::IdentityRel,
) where {W&lt;:AbstractWorld}
    [w]
end

# access all worlds
function accessibles(
    fr::FR{W},
    w::W,
    r::GlobalRel,
) where {W&lt;:AbstractWorld}
    allworlds(fr)
end</code></pre><p>In general, it should be true that <code>collect(accessibles(fr, w, r)) isa AbstractWorlds{W}</code>.</p><p>See also <a href="#SoleLogics.AbstractWorld-logic"><code>AbstractWorld</code></a>, <a href="#SoleLogics.AbstractRelation-logic"><code>AbstractRelation</code></a>, <a href="@ref"><code>AbstractMultiModalFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.2/src/types/modal-logic.jl#L268-L354">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../models/">Symbolic models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 2 September 2025 13:01">Tuesday 2 September 2025</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
