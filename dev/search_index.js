var documenterSearchIndex = {"docs":
[{"location":"parse/#Parsers","page":"Parsing models from other frameworks","title":"Parsers","text":"","category":"section"},{"location":"parse/#SoleModels.parse_orange_decision_list-parse","page":"Parsing models from other frameworks","title":"SoleModels.parse_orange_decision_list","text":"parse_orange_decision_list(decision_list, ignoredefaultrule = false; featuretype = SoleData.VariableValue)\n\nParser for orange-style decision lists. Reference: https://orange3.readthedocs.io/projects/orange-visual-programming/en/latest/widgets/model/cn2ruleinduction.html\n\nArguments\n\ndecision_list is an AbstractString containing the orange-style representation of a decision list;\nignoredefaultrule is an optional, Boolean parameter indicating whether to use the default rule   as the default rule for the resulting decision list.   When false, the last rule is ignored, and the second last is used as the default rule;\nfeaturetype specifies the feature type used in the parsed ScalarConditions.\n\nExamples\n\njulia> dl = \"\n[49, 0, 0] IF petal length<=3.0 AND sepal width>=2.9 THEN iris=Iris-setosa  -0.0\n[0, 0, 39] IF petal width>=1.8 AND sepal length>=6.0 THEN iris=Iris-virginica  -0.0\n[0, 8, 0] IF sepal length>=4.9 AND sepal width>=3.1 THEN iris=Iris-versicolor  -0.0\n[0, 0, 2] IF petal length<=4.9 AND petal width>=1.7 THEN iris=Iris-virginica  -0.0\n[0, 0, 5] IF petal width>=1.8 THEN iris=Iris-virginica  -0.0\n[0, 35, 0] IF petal length<=5.0 AND sepal width>=2.4 THEN iris=Iris-versicolor  -0.0\n[0, 0, 2] IF sepal width>=2.8 THEN iris=Iris-virginica  -0.0\n[0, 3, 0] IF petal width<=1.0 AND sepal length>=5.0 THEN iris=Iris-versicolor  -0.0\n[0, 1, 0] IF sepal width>=2.7 THEN iris=Iris-versicolor  -0.0\n[0, 0, 1] IF sepal width>=2.6 THEN iris=Iris-virginica  -0.0\n[0, 2, 0] IF sepal length>=5.5 AND sepal length>=6.2 THEN iris=Iris-versicolor  -0.0\n[0, 1, 0] IF sepal length<=5.5 AND petal length>=4.0 THEN iris=Iris-versicolor  -0.0\n[0, 0, 1] IF sepal length>=6.0 THEN iris=Iris-virginica  -0.0\n[1, 0, 0] IF sepal length<=4.5 THEN iris=Iris-setosa  -0.0\n[50, 50, 50] IF TRUE THEN iris=Iris-setosa  -1.584962500721156\n\" |> SoleModels.parse_orange_decision_list\n\njulia> listrules(dl; normalize = true)\n15-element Vector{ClassificationRule{String}}:\n ▣ ((:petal_length ≤ 3.0) ∧ (:sepal_width ≥ 2.9))  ↣  Iris-setosa\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width ≥ 1.8) ∧ (:sepal_length ≥ 6.0))  ↣  Iris-virginica\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length ≥ 4.9) ∧ (:sepal_width ≥ 3.1))  ↣  Iris-versicolor\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length ≤ 4.9) ∧ (:petal_width ≥ 1.7))  ↣  Iris-virginica\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width ≥ 1.8)  ↣  Iris-virginica\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length ≤ 5.0) ∧ (:sepal_width ≥ 2.4))  ↣  Iris-versicolor\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width ≥ 2.8)  ↣  Iris-virginica\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width ≤ 1.0) ∧ (:sepal_length ≥ 5.0))  ↣  Iris-versicolor\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width ≥ 2.7)  ↣  Iris-versicolor\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width < 2.7) ∧ (:sepal_width ≥ 2.6)  ↣  Iris-virginica\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width < 2.7) ∧ (:sepal_width < 2.6) ∧ ((:sepal_length ≥ 5.5) ∧ (:sepal_length ≥ 6.2))  ↣  Iris-versicolor\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width < 2.7) ∧ (:sepal_width < 2.6) ∧ ((:sepal_length < 5.5) ∨ (:sepal_length < 6.2)) ∧ ((:sepal_length ≤ 5.5) ∧ (:petal_length ≥ 4.0))  ↣  Iris-versicolor\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width < 2.7) ∧ (:sepal_width < 2.6) ∧ ((:sepal_length < 5.5) ∨ (:sepal_length < 6.2)) ∧ ((:sepal_length > 5.5) ∨ (:petal_length < 4.0)) ∧ (:sepal_length ≥ 6.0)  ↣  Iris-virginica\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width < 2.7) ∧ (:sepal_width < 2.6) ∧ ((:sepal_length < 5.5) ∨ (:sepal_length < 6.2)) ∧ ((:sepal_length > 5.5) ∨ (:petal_length < 4.0)) ∧ (:sepal_length < 6.0) ∧ (:sepal_length ≤ 4.5)  ↣  Iris-setosa\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width < 2.7) ∧ (:sepal_width < 2.6) ∧ ((:sepal_length < 5.5) ∨ (:sepal_length < 6.2)) ∧ ((:sepal_length > 5.5) ∨ (:petal_length < 4.0)) ∧ (:sepal_length < 6.0) ∧ (:sepal_length > 4.5)  ↣  Iris-setosa\n\n\nSee also DecisionList.\n\n\n\n\n\n","category":"function"},{"location":"models/#Symbolic-models","page":"Symbolic models","title":"Symbolic models","text":"","category":"section"},{"location":"models/","page":"Symbolic models","title":"Symbolic models","text":"","category":"page"},{"location":"models/#SoleModels.ConstantModel-models-2","page":"Symbolic models","title":"SoleModels.ConstantModel","text":"struct ConstantModel{O} <: LeafModel{O}\n    outcome::O\n    info::NamedTuple\nend\n\nThe simplest type of model is the ConstantModel; it is a LeafModel that always outputs the same outcome.\n\nExamples\n\njulia> cm = ConstantModel(2);\njulia> outcome(cm)\n2\n\nSee also apply, LeafModel.\n\n\n\n\n\n","category":"type"},{"location":"models/#SoleModels.FunctionModel-models-2","page":"Symbolic models","title":"SoleModels.FunctionModel","text":"struct FunctionModel{O} <: LeafModel{O}\n    f::FunctionWrapper{O}\n    info::NamedTuple\nend\n\nA FunctionModel is a LeafModel that applies a native Julia Function in order to compute the outcome.\n\nwarning: Warning\nOver efficiency concerns, it is mandatory to make explicit the output type O by wrapping the Function into an object of type FunctionWrapper{O} (see FunctionWrappers.\n\nSee also LeafModel.\n\n\n\n\n\n","category":"type"},{"location":"models/#SoleModels.Rule-models-2","page":"Symbolic models","title":"SoleModels.Rule","text":"struct Rule{O} <: AbstractModel{O}\n    antecedent::Formula\n    consequent::M where {M<:AbstractModel{<:O}}\n    info::NamedTuple\nend\n\nA Rule is one of the fundamental building blocks of symbolic modeling, and has the semantics:\n\nIF (antecedent) THEN (consequent) END\n\nwhere the antecedent is a formula to be checked, and the consequent is the local outcome of the block.\n\nExamples\n\njulia> Rule(CONJUNCTION(Atom(\"p\"), Atom(\"q\")), ConstantModel(2))\n▣ (p) ∧ (q)  ↣  2\n\nSee also AbstractModel, antecedent, consequent, SoleLogics.Formula.\n\n\n\n\n\n","category":"type"},{"location":"models/#SoleModels.Branch-models-2","page":"Symbolic models","title":"SoleModels.Branch","text":"struct Branch{O} <: AbstractModel{O}\n    antecedent::Formula\n    posconsequent::M where {M<:AbstractModel{<:O}}\n    negconsequent::M where {M<:AbstractModel{<:O}}\n    info::NamedTuple\nend\n\nA Branch is one of the fundamental building blocks of symbolic modeling, and has the semantics:\n\nIF (antecedent) THEN (positive consequent) ELSE (negative consequent) END\n\nwhere the antecedent is a formula to be checked and the consequents are the feasible local outcomes of the block. If checking the antecedent evaluates to the top of the algebra, then the positive consequent is applied; otherwise, the negative consequent is applied.\n\nSee also AbstractModel, antecedent, SoleLogics.check, SoleLogics.Formula, negconsequent, posconsequent, Rule.\n\n\n\n\n\n","category":"type"},{"location":"models/#SoleModels.DecisionList-models-2","page":"Symbolic models","title":"SoleModels.DecisionList","text":"struct DecisionList{O} <: AbstractModel{O}\n    rulebase::Vector{Rule{_O} where {_O<:O}}\n    defaultconsequent::M where {M<:AbstractModel{<:O}}\n    info::NamedTuple\nend\n\nA DecisionList (or decision table, or rule-based model) is a symbolic model that has the semantics of an IF-ELSEIF-ELSE block:\n\nIF (antecedent_1)     THEN (consequent_1)\nELSEIF (antecedent_2) THEN (consequent_2)\n...\nELSEIF (antecedent_n) THEN (consequent_n)\nELSE (consequent_default) END\n\nwhere the antecedents are formulas to be, and the consequents are the feasible local outcomes of the block.\n\nUsing the classical semantics, the antecedents are evaluated in order, and a consequent is returned as soon as a valid antecedent is found, or when the computation reaches the ELSE clause.\n\nSee also AbstractModel, DecisionTree, Rule.\n\n\n\n\n\n","category":"type"},{"location":"models/#SoleModels.DecisionTree-models-2","page":"Symbolic models","title":"SoleModels.DecisionTree","text":"struct DecisionTree{O} <: AbstractModel{O}\n    root::M where {M<:Union{LeafModel{O},Branch{O}}}\n    info::NamedTuple\nend\n\nDecisionTree wraps a constrained sub-tree of Branch and LeafModel.\n\nIn other words, a DecisionTree is a symbolic model that operates as a nested structure of IF-THEN-ELSE blocks:\n\nIF (antecedent_1) THEN\n    IF (antecedent_2) THEN\n        (consequent_1)\n    ELSE\n        (consequent_2)\n    END\nELSE\n    IF (antecedent_3) THEN\n        (consequent_3)\n    ELSE\n        (consequent_4)\n    END\nEND\n\nwhere the antecedents are formulas to be, and the consequents are the feasible local outcomes of the block.\n\n!!!note     Note that this structure also includes an info::NamedTuple for storing additional     information.\n\nSee also Branch, DecisionList, DecisionForest, LeafModel, MixedModel.\n\n\n\n\n\n","category":"type"},{"location":"models/#SoleModels.DecisionForest-models-2","page":"Symbolic models","title":"SoleModels.DecisionForest","text":"const DecisionForest{O} = DecisionEnsemble{<:DecisionTree{O}}\n\nA DecisionForest is an ensemble of (unweighted) DecisionTree's, aggregated by bestguess.\n\nSee also DecisionEnsemble, DecisionTree, MaxDecisionBag, bestguess.\n\n\n\n\n\n","category":"type"},{"location":"models/#SoleModels.printmodel-models","page":"Symbolic models","title":"SoleModels.printmodel","text":"printmodel(io::IO, m::AbstractModel; kwargs...)\ndisplaymodel(m::AbstractModel; kwargs...)\n\nprint or return a string representation of model m.\n\nArguments\n\nheader::Bool = false: when set to true, a header is printed, displaying the info structure for m;\nshow_subtree_info::Bool = false: when set to true, the header is printed for models in the sub-tree of m;\nshow_metrics::Bool = false: when set to true, performance metrics at each point of the subtree are shown, whenever they are available in the info structure;\nmax_depth::Union{Nothing,Int} = nothing: when it is an Int, models in the sub-tree with a depth higher than max_depth are ellipsed with \"...\";\nsyntaxstring_kwargs::NamedTuple = (;): kwargs to be passed to syntaxstring for formatting logical formulas.\n\nSee also syntaxstring, AbstractModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#Evaluating-symbolic-models","page":"Symbolic models","title":"Evaluating symbolic models","text":"","category":"section"},{"location":"models/#SoleModels.evaluaterule-Tuple{Rule, SoleLogics.AbstractInterpretationSet, AbstractVector{<:Union{AbstractString, Real, Symbol, CategoricalArrays.CategoricalValue}}}-models-2","page":"Symbolic models","title":"SoleModels.evaluaterule","text":"evaluaterule(\n    r::Rule{O},\n    X::AbstractInterpretationSet,\n    Y::AbstractVector{L}\n) where {O,L<:Label}\n\nEvaluate the rule on a labeled dataset, and return a NamedTuple consisting of:\n\ncheckmask::Vector{Bool}: satsfaction of the antecedent for each instance in the dataset;\nys::Vector{Union{Nothing,O}}: rule prediction. For each instance in X:\nconsequent(rule) if the antecedent is satisfied,\nnothing otherwise.\n\nSee also Rule, SoleLogics.AbstractInterpretationSet, Label, checkantecedent.\n\n\n\n\n\n","category":"method"},{"location":"models/#SoleModels.evaluaterule-Union{Tuple{L}, Tuple{ClassificationRule{L}, SoleLogics.AbstractInterpretationSet, AbstractVector{<:Union{AbstractString, Real, Symbol, CategoricalArrays.CategoricalValue}}}} where L<:Union{AbstractString, Symbol, CategoricalArrays.CategoricalValue}-models-2","page":"Symbolic models","title":"SoleModels.evaluaterule","text":"TODO\n\n\n\n\n\n","category":"method"},{"location":"models/#SoleModels.readmetrics-Union{Tuple{LeafModel{L}}, Tuple{L}} where L<:Union{AbstractString, Real, Symbol, CategoricalArrays.CategoricalValue}-models-2","page":"Symbolic models","title":"SoleModels.readmetrics","text":"readmetrics(m::AbstractModel; round_digits = nothing)\n\nReturn a NamedTuple with some performance metrics for the given symbolic model. Performance metrics can be computed when the info structure of the model has the following keys:\n\n:supporting_labels\n:supporting_predictions\n\nThe round_digits keyword argument, if provided, is used to round accuracy/confidence metrics.\n\n\n\n\n\n","category":"method"},{"location":"models/#SoleModels.rulemetrics-Tuple{Rule, SoleLogics.AbstractInterpretationSet, AbstractVector{<:Union{AbstractString, Real, Symbol, CategoricalArrays.CategoricalValue}}}-models-2","page":"Symbolic models","title":"SoleModels.rulemetrics","text":"rulemetrics(\n    r::Rule,\n    X::AbstractInterpretationSet,\n    Y::AbstractVector{<:Label}\n)\n\nCompute metrics for a rule with respect to a labeled dataset and returns a NamedTuple consisting of:\n\ncoverage: number of instances satisfying the antecedent of the rule divided by   the total number of instances;\nerror:\nFor classification problems: number of instances that were not classified\ncorrectly divided by the total number of instances;\nFor regression problems: mean squared error;\nlength: number of atoms in the rule's antecedent.\n\nSee also Rule, SoleLogics.AbstractInterpretationSet, Label, evaluaterule, outcometype, consequent.\n\n\n\n\n\n","category":"method"},{"location":"models/#Manipulating-symbolic-knowledge","page":"Symbolic models","title":"Manipulating symbolic knowledge","text":"","category":"section"},{"location":"models/#SoleModels.submodels-Tuple{AbstractModel}-models-3","page":"Symbolic models","title":"SoleModels.submodels","text":"submodels(m::AbstractModel)\n\nEnumerate all submodels in the sub-tree. This function is the transitive closure of immediatesubmodels; in fact, the returned list includes the immediate submodels (immediatesubmodels(m)), but also their immediate submodels, and so on.\n\nExamples\n\njulia> using SoleLogics\n\njulia> branch = Branch(SoleLogics.parseformula(\"p∧q∨r\"), \"YES\", \"NO\");\n\njulia> submodels(branch)\n2-element Vector{SoleModels.ConstantModel{String}}:\n ConstantModel\nYES\n\n ConstantModel\nNO\n\n\njulia> branch2 = Branch(SoleLogics.parseformula(\"s→p\"), branch, 42);\n\njulia> printmodel.(submodels(branch2));\nBranch\n┐ p ∧ (q ∨ r)\n├ ✔ YES\n└ ✘ NO\n\nConstantModel\nYES\n\nConstantModel\nNO\n\nConstantModel\n42\n\njulia> submodels(branch) == immediatesubmodels(branch)\ntrue\n\njulia> submodels(branch2) == immediatesubmodels(branch2)\nfalse\n\nSee also AbstractModel, immediatesubmodels, LeafModel.\n\n\n\n\n\n","category":"method"},{"location":"#SoleModels","page":"Home","title":"SoleModels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for SoleModels, the first ever framework for symbolic learning. This package provides the basic structures for representing symbolic models. Note that it does not provide any implementation of symbolic learning algorithms. At the current state, ModalDecisionTrees is the only implemented algorithm that is Sole-compatible.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"autodocs/#Full-Reference","page":"Full reference","title":"Full Reference","text":"","category":"section"},{"location":"autodocs/","page":"Full reference","title":"Full reference","text":"","category":"page"},{"location":"autodocs/#SoleModels.AbstractModel","page":"Full reference","title":"SoleModels.AbstractModel","text":"abstract type AbstractModel{O} end\n\nAbstract type for symbolic models that, given an instance object (i.e., a piece of data), output an outcome of type O.\n\nA model is said to be symbolic when its application relies on checking formulas of a certain logical language (see SoleLogics.jl package) on the instance. Symbolic models provide a form of transparent and interpretable modeling, as a symbolic model can be synthethised into a set of mutually exclusive logical rules that can often be translated into natural language.\n\nExamples of symbolic models are Rules, Branches, DecisionLists and DecisionTrees. Examples of non-symbolic (or sub-symbolic) models include those encoding algebraic mathematical functions (e.g., neural networks).\n\nSymbolic models can wrap other AbstractModels, and use them to compute the outcome. As such, an AbstractModel can actually be the result of a composition of many models, and enclose a tree of AbstractModels (with LeafModels at the leaves).\n\nTODO - bring missing dispatches here (do the same for other model types)\n\nInterface\n\napply(m::AbstractModel, i::AbstractInterpretation; kwargs...)\niscomplete(m::AbstractModel)\noutcometype(m::AbstractModel)\noutputtype(m::AbstractModel)\nimmediatesubmodels(m::AbstractModel)\nnimmediatesubmodels(m::AbstractModel)\nlistimmediaterules(m::AbstractModel)\ninfo(m::AbstractModel, [key, [defaultval]])\ninfo!(m::AbstractModel, key, value)\nhasinfo(m::AbstractModel, key)\n\nUtility functions\n\napply(m::AbstractModel, i::AbstractInterpretationSet; kwargs...)\nSee AbstractTrees...\nsubmodels(m::AbstractModel)\nnsubmodels(m::AbstractModel)\nleafmodels(m::AbstractModel)\nnleafmodels(m::AbstractModel)\nsubtreeheight(m::AbstractModel)\nlistrules(       m::AbstractModel;       use_shortforms::Bool=true,       use_leftmostlinearform::Union{Nothing,Bool}=nothing,       normalize::Bool=false,       force_syntaxtree::Bool=false,   )\njoinrules(m::AbstractModel, silent=false; kwargs...)\n\nExamples\n\nTODO\n\nSee also apply, Branch, info, iscomplete, LeafModel, outcometype, Rule.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.Branch","page":"Full reference","title":"SoleModels.Branch","text":"struct Branch{O} <: AbstractModel{O}\n    antecedent::Formula\n    posconsequent::M where {M<:AbstractModel{<:O}}\n    negconsequent::M where {M<:AbstractModel{<:O}}\n    info::NamedTuple\nend\n\nA Branch is one of the fundamental building blocks of symbolic modeling, and has the semantics:\n\nIF (antecedent) THEN (positive consequent) ELSE (negative consequent) END\n\nwhere the antecedent is a formula to be checked and the consequents are the feasible local outcomes of the block. If checking the antecedent evaluates to the top of the algebra, then the positive consequent is applied; otherwise, the negative consequent is applied.\n\nSee also AbstractModel, antecedent, SoleLogics.check, SoleLogics.Formula, negconsequent, posconsequent, Rule.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.ConstantModel","page":"Full reference","title":"SoleModels.ConstantModel","text":"struct ConstantModel{O} <: LeafModel{O}\n    outcome::O\n    info::NamedTuple\nend\n\nThe simplest type of model is the ConstantModel; it is a LeafModel that always outputs the same outcome.\n\nExamples\n\njulia> cm = ConstantModel(2);\njulia> outcome(cm)\n2\n\nSee also apply, LeafModel.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.DecisionEnsemble","page":"Full reference","title":"SoleModels.DecisionEnsemble","text":"struct DecisionEnsemble{O,T<:AbstractModel,A<:Base.Callable,W<:Union{Nothing,AbstractVector}} <: AbstractDecisionEnsemble{O}\n    models::Vector{T}\n    aggregation::A\n    weights::W\n    info::NamedTuple\nend\n\nA DecisionEnsemble is an ensemble of models; upon prediction, all models are used, and an aggregation function is used to pool their outputs. Optionally, model weights can be specified.\n\nSee also DecisionForest, DecisionTree, MaxDecisionBag.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.DecisionForest","page":"Full reference","title":"SoleModels.DecisionForest","text":"const DecisionForest{O} = DecisionEnsemble{<:DecisionTree{O}}\n\nA DecisionForest is an ensemble of (unweighted) DecisionTree's, aggregated by bestguess.\n\nSee also DecisionEnsemble, DecisionTree, MaxDecisionBag, bestguess.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.DecisionList","page":"Full reference","title":"SoleModels.DecisionList","text":"struct DecisionList{O} <: AbstractModel{O}\n    rulebase::Vector{Rule{_O} where {_O<:O}}\n    defaultconsequent::M where {M<:AbstractModel{<:O}}\n    info::NamedTuple\nend\n\nA DecisionList (or decision table, or rule-based model) is a symbolic model that has the semantics of an IF-ELSEIF-ELSE block:\n\nIF (antecedent_1)     THEN (consequent_1)\nELSEIF (antecedent_2) THEN (consequent_2)\n...\nELSEIF (antecedent_n) THEN (consequent_n)\nELSE (consequent_default) END\n\nwhere the antecedents are formulas to be, and the consequents are the feasible local outcomes of the block.\n\nUsing the classical semantics, the antecedents are evaluated in order, and a consequent is returned as soon as a valid antecedent is found, or when the computation reaches the ELSE clause.\n\nSee also AbstractModel, DecisionTree, Rule.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.DecisionSet","page":"Full reference","title":"SoleModels.DecisionSet","text":"struct DecisionSet{O} <: AbstractModel{O}\n\nA DecisionSet is a symbolic model that wraps a set of final rules. A DecisionSet is non-overlapping (isnonoverlapping) if all rules are mutually exclusive, and is complete (iscomplete) if all rules jointly exaustive. Any symbolic model can be transformed into a non-overlapping DecisionSet (via ruleset), and if the starting model is complete, then also the resulting decision set is complete.\n\nIf the model is non-overlapping, then at most one rule applies to any given an logical interpretation. If the model is complete, then at least one rule applies to any given an logical interpretation.\n\nTODO how are racing cases handled???\n\nSee also AbstractModel, DecisionSet, Rule.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.DecisionTree","page":"Full reference","title":"SoleModels.DecisionTree","text":"struct DecisionTree{O} <: AbstractModel{O}\n    root::M where {M<:Union{LeafModel{O},Branch{O}}}\n    info::NamedTuple\nend\n\nDecisionTree wraps a constrained sub-tree of Branch and LeafModel.\n\nIn other words, a DecisionTree is a symbolic model that operates as a nested structure of IF-THEN-ELSE blocks:\n\nIF (antecedent_1) THEN\n    IF (antecedent_2) THEN\n        (consequent_1)\n    ELSE\n        (consequent_2)\n    END\nELSE\n    IF (antecedent_3) THEN\n        (consequent_3)\n    ELSE\n        (consequent_4)\n    END\nEND\n\nwhere the antecedents are formulas to be, and the consequents are the feasible local outcomes of the block.\n\n!!!note     Note that this structure also includes an info::NamedTuple for storing additional     information.\n\nSee also Branch, DecisionList, DecisionForest, LeafModel, MixedModel.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.DecisionXGBoost","page":"Full reference","title":"SoleModels.DecisionXGBoost","text":"A DecisionXGBoost is an ensemble of models, weighted by leaf values, exp.summed during apply.\n\nSee also DecisionForest, DecisionTree, DecisionEnsemble, MaxDecisionBag.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.FunctionModel","page":"Full reference","title":"SoleModels.FunctionModel","text":"struct FunctionModel{O} <: LeafModel{O}\n    f::FunctionWrapper{O}\n    info::NamedTuple\nend\n\nA FunctionModel is a LeafModel that applies a native Julia Function in order to compute the outcome.\n\nwarning: Warning\nOver efficiency concerns, it is mandatory to make explicit the output type O by wrapping the Function into an object of type FunctionWrapper{O} (see FunctionWrappers.\n\nSee also LeafModel.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.LeafModel","page":"Full reference","title":"SoleModels.LeafModel","text":"abstract type LeafModel{O} <: AbstractModel{O} end\n\nAbstract type for leaf models, that is, models which outcomes do not depend other models, and represents the bottom of the computation.\n\nIn general, an AbstractModel can generally wrap other AbstractModels; in such case, the outcome can depend on the inner models being applied on the instance object. Otherwise, the model is considered as a leaf, or final, and is the leaf of a tree of AbstractModels.\n\nExamples\n\njulia> SoleModels.LeafModel(2) isa SoleModels.ConstantModel\n\njulia> SoleModels.LeafModel(sum) isa SoleModels.FunctionModel\n┌ Warning: Over efficiency concerns, please consider wrappingJulia Function's into FunctionWrapper{O,Tuple{SoleModels.AbstractInterpretation}} structures,where O is their return type.\n└ @ SoleModels ~/.julia/dev/SoleModels/src/base.jl:337\ntrue\n\nSee also AbstractModel, ConstantModel, FunctionModel.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.MixedModel","page":"Full reference","title":"SoleModels.MixedModel","text":"struct MixedModel{O,FM<:AbstractModel} <: AbstractModel{O}\n    root::M where {M<:AbstractModel{<:O}}\n    info::NamedTuple\nend\n\nA MixedModel is a wrapper of multiple AbstractModels such as Rules, Branchs, DecisionLists, DecisionTree.\n\nIn other words, a MixedModel is a symbolic model that operates as a free nested structure of IF-THEN-ELSE and IF-ELSEIF-ELSE blocks:\n\nIF (antecedent_1) THEN\n    IF (antecedent_1)     THEN (consequent_1)\n    ELSEIF (antecedent_2) THEN (consequent_2)\n    ELSE (consequent_1_default) END\nELSE\n    IF (antecedent_3) THEN\n        (consequent_3)\n    ELSE\n        (consequent_4)\n    END\nEND\n\nwhere the antecedents are formulas to be checked, and the consequents are the feasible local outcomes of the block.\n\nnote: Note\nNote that FM refers to the Feasible Models (FM) allowed in the model's sub-tree.\n\nSee also AbstractModel, Branchs, DecisionLists, DecisionTree, Rules.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.PlainRuleExtractor","page":"Full reference","title":"SoleModels.PlainRuleExtractor","text":"Plain extraction method involves listing one rule per each possible symbolic path within the model. With this method, extractrules redirects to listrules.\n\nSee also listrules, Rule], issymbolicmodel.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.Rule","page":"Full reference","title":"SoleModels.Rule","text":"struct Rule{O} <: AbstractModel{O}\n    antecedent::Formula\n    consequent::M where {M<:AbstractModel{<:O}}\n    info::NamedTuple\nend\n\nA Rule is one of the fundamental building blocks of symbolic modeling, and has the semantics:\n\nIF (antecedent) THEN (consequent) END\n\nwhere the antecedent is a formula to be checked, and the consequent is the local outcome of the block.\n\nExamples\n\njulia> Rule(CONJUNCTION(Atom(\"p\"), Atom(\"q\")), ConstantModel(2))\n▣ (p) ∧ (q)  ↣  2\n\nSee also AbstractModel, antecedent, consequent, SoleLogics.Formula.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.RuleExtractor","page":"Full reference","title":"SoleModels.RuleExtractor","text":"An exact or heuristic logical method for extracting logical rule from symbolic models.\n\nRefer to SolePostHoc for rule extraction methods.\n\nSee also extractrules, Rule], issymbolicmodel.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleLogics.atoms-Tuple{AbstractModel}","page":"Full reference","title":"SoleLogics.atoms","text":"atoms(::AbstractModel)\nconnectives(::AbstractModel)\nsyntaxleaves(::AbstractModel)\n\nnatoms(::AbstractModel)\nnconnectives(::AbstractModel)\nnsyntaxleaves(::AbstractModel)\n\nSee also AbstractModel, listrules.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.connectives-Tuple{AbstractModel}","page":"Full reference","title":"SoleLogics.connectives","text":"atoms(::AbstractModel)\nconnectives(::AbstractModel)\nsyntaxleaves(::AbstractModel)\n\nnatoms(::AbstractModel)\nnconnectives(::AbstractModel)\nnsyntaxleaves(::AbstractModel)\n\nSee also AbstractModel, listrules.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.height-Tuple{DecisionEnsemble}","page":"Full reference","title":"SoleLogics.height","text":"function height(m::DecisionEnsemble)\n\nReturn the maximum height across all the DecisionTrees within m.\n\nSee also DecisionEnsemble, DecisionTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.height-Tuple{DecisionTree}","page":"Full reference","title":"SoleLogics.height","text":"function height(m::DecisionTree)\n\nReturn the height of m.\n\nSee also DecisionTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.height-Tuple{DecisionXGBoost}","page":"Full reference","title":"SoleLogics.height","text":"function height(m::DecisionXGBoost)\n\nReturn the maximum height across all the DecisionTrees within m.\n\nSee also DecisionXGBoost, DecisionForest](@ref), DecisionTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.natoms-Tuple{AbstractModel}","page":"Full reference","title":"SoleLogics.natoms","text":"atoms(::AbstractModel)\nconnectives(::AbstractModel)\nsyntaxleaves(::AbstractModel)\n\nnatoms(::AbstractModel)\nnconnectives(::AbstractModel)\nnsyntaxleaves(::AbstractModel)\n\nSee also AbstractModel, listrules.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.nconnectives-Tuple{AbstractModel}","page":"Full reference","title":"SoleLogics.nconnectives","text":"atoms(::AbstractModel)\nconnectives(::AbstractModel)\nsyntaxleaves(::AbstractModel)\n\nnatoms(::AbstractModel)\nnconnectives(::AbstractModel)\nnsyntaxleaves(::AbstractModel)\n\nSee also AbstractModel, listrules.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.nleaves-Tuple{DecisionEnsemble}","page":"Full reference","title":"SoleLogics.nleaves","text":"function nleaves(m::DecisionEnsemble)\n\nReturn the number of LeafModel within m.\n\nSee also DecisionEnsemble, DecisionTree, LeafModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleLogics.nleaves-Tuple{DecisionTree}","page":"Full reference","title":"SoleLogics.nleaves","text":"function nleaves(m::DecisionTree)\n\nReturn the number of leaves in m.\n\nSee also DecisionTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.antecedent-Tuple{Rule}","page":"Full reference","title":"SoleModels.antecedent","text":"antecedent(m::Union{Rule,Branch})::Formula\n\nReturn the antecedent of a Rule or a Branch, that is, the formula to be checked upon applying the model.\n\nSee also apply, Branch, checkantecedent, consequent, Rule.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.apply-Tuple{AbstractModel, SoleLogics.AbstractInterpretation}","page":"Full reference","title":"SoleModels.apply","text":"apply(m::AbstractModel, i::AbstractInterpretation; kwargs...)::outputtype(m)\n\napply(\n    m::AbstractModel,\n    d::AbstractInterpretationSet;\n    kwargs...\n)::AbstractVector{<:outputtype(m)}\n\nReturn the output prediction of a model m on a logical interpretation i, on the i_instance of a dataset d, or on all instances of a dataset d. Note that predictions can be nothing if the model is incomplete (e.g., if the model is a Rule).\n\nKeyword Arguments\n\ncheck_args::Tuple = ();\ncheck_kwargs::NamedTuple = (;);\nfunctional_args::Tuple = ();\nfunctional_kwargs::NamedTuple = (;);\nAny additional keyword argument is passed down to the model subtree's leaves\n\ncheck_args and check_kwargs can influence check's behavior at the time of its computation (see SoleLogics.check).\n\nfunctional_args and functional_kwargs can influence FunctionModel's behavior when the corresponding function is applied to AbstractInterpretation (see FunctionModel, SoleLogics.AbstractInterpretation)\n\nA model state-changing version of the function, [apply!], exist. While producing the output, this function affects the info keys :supporting_labels and :supporting_predictions, which are useful for inspecting the statistical performance of parts of the model.\n\nSee also SoleLogics.AbstractInterpretation, SoleLogics.AbstractInterpretationSet, AbstractModel, iscomplete, readmetrics.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.checkantecedent","page":"Full reference","title":"SoleModels.checkantecedent","text":"checkantecedent(\n    m::Union{Rule,Branch},\n    args...;\n    kwargs...\n)\n    check(antecedent(m), args...; kwargs...)\nend\n\nCheck the antecedent of a Rule or a Branch, on an instance or dataset.\n\nSee also antecedent, Rule, Branch.\n\n\n\n\n\n","category":"function"},{"location":"autodocs/#SoleModels.consequent-Tuple{Rule}","page":"Full reference","title":"SoleModels.consequent","text":"consequent(m::Rule)::AbstractModel\n\nReturn the consequent of m.\n\nSee also antecedent, Rule.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.defaultconsequent-Tuple{DecisionList}","page":"Full reference","title":"SoleModels.defaultconsequent","text":"defaultconsequent(m::DecisionList)\n\nReturn the default consequent of m.\n\nnote: Note\nThe returned model is complete if and only if m is complete. See also iscomplete.\n\nSee also AbstractModel, DecisionList, Rule.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.displaymodel-Tuple{AbstractModel}","page":"Full reference","title":"SoleModels.displaymodel","text":"printmodel(io::IO, m::AbstractModel; kwargs...)\ndisplaymodel(m::AbstractModel; kwargs...)\n\nprint or return a string representation of model m.\n\nArguments\n\nheader::Bool = false: when set to true, a header is printed, displaying the info structure for m;\nshow_subtree_info::Bool = false: when set to true, the header is printed for models in the sub-tree of m;\nshow_metrics::Bool = false: when set to true, performance metrics at each point of the subtree are shown, whenever they are available in the info structure;\nmax_depth::Union{Nothing,Int} = nothing: when it is an Int, models in the sub-tree with a depth higher than max_depth are ellipsed with \"...\";\nsyntaxstring_kwargs::NamedTuple = (;): kwargs to be passed to syntaxstring for formatting logical formulas.\n\nSee also syntaxstring, AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.evaluaterule-Tuple{Rule, SoleLogics.AbstractInterpretationSet, AbstractVector{<:Union{AbstractString, Real, Symbol, CategoricalArrays.CategoricalValue}}}","page":"Full reference","title":"SoleModels.evaluaterule","text":"evaluaterule(\n    r::Rule{O},\n    X::AbstractInterpretationSet,\n    Y::AbstractVector{L}\n) where {O,L<:Label}\n\nEvaluate the rule on a labeled dataset, and return a NamedTuple consisting of:\n\ncheckmask::Vector{Bool}: satsfaction of the antecedent for each instance in the dataset;\nys::Vector{Union{Nothing,O}}: rule prediction. For each instance in X:\nconsequent(rule) if the antecedent is satisfied,\nnothing otherwise.\n\nSee also Rule, SoleLogics.AbstractInterpretationSet, Label, checkantecedent.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.evaluaterule-Union{Tuple{L}, Tuple{ClassificationRule{L}, SoleLogics.AbstractInterpretationSet, AbstractVector{<:Union{AbstractString, Real, Symbol, CategoricalArrays.CategoricalValue}}}} where L<:Union{AbstractString, Symbol, CategoricalArrays.CategoricalValue}","page":"Full reference","title":"SoleModels.evaluaterule","text":"TODO\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.extractrules-Tuple{SoleModels.RuleExtractor, Any, Vararg{Any}}","page":"Full reference","title":"SoleModels.extractrules","text":"extractrules(re::RuleExtractor, m, args...; kwargs...)\n\nExtract rules from symbolic model m, using a rule extraction method re.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.f-Tuple{FunctionModel}","page":"Full reference","title":"SoleModels.f","text":"f(m::FunctionModel)\n\nReturn the FunctionWrapper within m.\n\nSee also FunctionModel, FunctionWrappers.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.hasinfo-Tuple{AbstractModel, Any}","page":"Full reference","title":"SoleModels.hasinfo","text":"hasinfo(m::AbstractModel, key)\n\nSee also AbstractModel, info.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.haslistrules-Tuple{Any}","page":"Full reference","title":"SoleModels.haslistrules","text":"haslistrules(m::Any)\n\nThis function extracts symbolic final rules from a symbolic model..\n\nSee also AbstractModel, listrules LeafModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.immediatesubmodels-Union{Tuple{AbstractModel{O}}, Tuple{O}} where O","page":"Full reference","title":"SoleModels.immediatesubmodels","text":"immediatesubmodels(m::AbstractModel)\n\nReturn the list of immediate child models.\n\nnote: Note\nIf the model is a leaf model, then the returned list will be empty.\n\nExamples\n\njulia> using SoleLogics\n\njulia> branch = Branch(SoleLogics.parseformula(\"p∧q∨r\"), \"YES\", \"NO\");\n\njulia> immediatesubmodels(branch)\n2-element Vector{SoleModels.ConstantModel{String}}:\n SoleModels.ConstantModel{String}\nYES\n\n SoleModels.ConstantModel{String}\nNO\n\njulia> branch2 = Branch(SoleLogics.parseformula(\"s→p\"), branch, 42);\n\n\njulia> printmodel.(immediatesubmodels(branch2));\nBranch\n┐ p ∧ (q ∨ r)\n├ ✔ YES\n└ ✘ NO\n\nConstantModel\n42\n\nSee also AbstractModel, LeafModel, submodels.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.info!-Tuple{AbstractModel, Any}","page":"Full reference","title":"SoleModels.info!","text":"info!(m::AbstractModel, info::NamedTuple; replace::Bool=false)\ninfo!(m::AbstractModel, key, val)\n\nOverwrite the info structure within m.\n\nKeyword Arguments\n\nreplace::Bool: overwrite the entire info structure.\n\nSee also AbstractModel, info.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.info-Tuple{AbstractModel}","page":"Full reference","title":"SoleModels.info","text":"info(m::AbstractModel)::NamedTuple = m.info\ninfo(m::AbstractModel, key) = m.info[key]\ninfo(m::AbstractModel, key, defaultval)\n\nReturn the info structure for model m; this structure is used for storing additional information that does not affect the model's behavior.\n\nThis structure can hold, for example, information about the model's statistical performance during the learning phase.\n\nSee also AbstractModel, info!.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.iscomplete-Tuple{AbstractModel}","page":"Full reference","title":"SoleModels.iscomplete","text":"iscomplete(::AbstractModel)::Bool\n\nReturn whether a model is complete.\n\nAn AbstractModel is complete if it is always able to provide an outcome of type O. Otherwise, the model can output nothing values and is referred to as incomplete.\n\nRule is an example of an incomplete model, while Branch is an example of complete model.\n\nSee also AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.isexact-Tuple{SoleModels.RuleExtractor}","page":"Full reference","title":"SoleModels.isexact","text":"Return whether a rule extraction method is known to be exact (as opposed to heuristic).\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.issymbolicmodel-Tuple{Any}","page":"Full reference","title":"SoleModels.issymbolicmodel","text":"abstract type AbstractModel{O} end\n\nAbstract type for symbolic models that, given an instance object (i.e., a piece of data), output an outcome of type O.\n\nA model is said to be symbolic when its application relies on checking formulas of a certain logical language (see SoleLogics.jl package) on the instance. Symbolic models provide a form of transparent and interpretable modeling, as a symbolic model can be synthethised into a set of mutually exclusive logical rules that can often be translated into natural language.\n\nExamples of symbolic models are Rules, Branches, DecisionLists and DecisionTrees. Examples of non-symbolic (or sub-symbolic) models include those encoding algebraic mathematical functions (e.g., neural networks).\n\nSymbolic models can wrap other AbstractModels, and use them to compute the outcome. As such, an AbstractModel can actually be the result of a composition of many models, and enclose a tree of AbstractModels (with LeafModels at the leaves).\n\nTODO - bring missing dispatches here (do the same for other model types)\n\nInterface\n\napply(m::AbstractModel, i::AbstractInterpretation; kwargs...)\niscomplete(m::AbstractModel)\noutcometype(m::AbstractModel)\noutputtype(m::AbstractModel)\nimmediatesubmodels(m::AbstractModel)\nnimmediatesubmodels(m::AbstractModel)\nlistimmediaterules(m::AbstractModel)\ninfo(m::AbstractModel, [key, [defaultval]])\ninfo!(m::AbstractModel, key, value)\nhasinfo(m::AbstractModel, key)\n\nUtility functions\n\napply(m::AbstractModel, i::AbstractInterpretationSet; kwargs...)\nSee AbstractTrees...\nsubmodels(m::AbstractModel)\nnsubmodels(m::AbstractModel)\nleafmodels(m::AbstractModel)\nnleafmodels(m::AbstractModel)\nsubtreeheight(m::AbstractModel)\nlistrules(       m::AbstractModel;       use_shortforms::Bool=true,       use_leftmostlinearform::Union{Nothing,Bool}=nothing,       normalize::Bool=false,       force_syntaxtree::Bool=false,   )\njoinrules(m::AbstractModel, silent=false; kwargs...)\n\nExamples\n\nTODO\n\nSee also apply, Branch, info, iscomplete, LeafModel, outcometype, Rule.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.joinrules","page":"Full reference","title":"SoleModels.joinrules","text":"joinrules(rules::AbstractVector{<:Rule})::Vector{<:Rule}\n\nReturn a set of rules, with exactly one rule per different outcome from the input set of rules. For each outcome, the output rule is computed as the logical disjunction of the antecedents of the input rules for that outcome.\n\nExamples\n\njulia> using SoleLogics\n\njulia> branch = Branch(SoleLogics.parseformula(\"p\"), Branch(SoleLogics.parseformula(\"q\"), \"YES\", \"NO\"), \"NO\")\n p\n├✔ q\n│├✔ YES\n│└✘ NO\n└✘ NO\n\n\njulia> printmodel.(listrules(branch); tree_mode = true);\n▣ p ∧ q\n└✔ YES\n\n▣ p ∧ ¬q\n└✔ NO\n\n▣ ¬p\n└✔ NO\n\njulia> printmodel.(joinrules(listrules(branch)); tree_mode = true);\n▣ (p ∧ q)\n└✔ YES\n\n▣ (p ∧ ¬q) ∨ ¬p\n└✔ NO\n\n\nSee also listrules, SoleLogics.DISJUNCTION, LeafModel, AbstractModel.\n\n\n\n\n\n","category":"function"},{"location":"autodocs/#SoleModels.listimmediaterules-Tuple{AbstractModel}","page":"Full reference","title":"SoleModels.listimmediaterules","text":"listimmediaterules(m::AbstractModel{O} where {O})::Rule{<:O}\n\nList the immediate rules equivalent to a symbolic model.\n\nExamples\n\njulia> using SoleLogics\n\njulia> branch = Branch(SoleLogics.parseformula(\"p\"), Branch(SoleLogics.parseformula(\"q\"), \"YES\", \"NO\"), \"NO\")\n p\n├✔ q\n│├✔ YES\n│└✘ NO\n└✘ NO\n\n\njulia> printmodel.(listimmediaterules(branch); tree_mode = true);\n▣ p\n└✔ q\n ├✔ YES\n └✘ NO\n\n▣ ¬(p)\n└✔ NO\n\nSee also AbstractModel, listrules.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.listrules-Tuple{Any}","page":"Full reference","title":"SoleModels.listrules","text":"listrules(\n    m::AbstractModel;\n    use_shortforms::Bool = true,\n    use_leftmostlinearform::Union{Nothing,Bool} = nothing,\n    normalize::Bool = false,\n    force_syntaxtree::Bool = false,\n)::Vector{<:Rule}\n\nReturn a list of rules capturing the knowledge enclosed in symbolic model. The behavior of any symbolic model can be synthesised and represented as a set of mutually exclusive (and jointly exaustive, if the model is closed) rules, which can be useful for many purposes.\n\nThe keyword argument force_syntaxtree, when set to true, causes the logical antecedents in the returned rules to be represented as SyntaxTrees, as opposed to other syntax structure (e.g., LeftmostConjunctiveForm).\n\nExamples\n\njulia> using SoleLogics\n\njulia> branch = Branch(SoleLogics.parseformula(\"p\"), Branch(SoleLogics.parseformula(\"q\"), \"YES\", \"NO\"), \"NO\")\n p\n├✔ q\n│├✔ YES\n│└✘ NO\n└✘ NO\n\njulia> printmodel.(listrules(branch); tree_mode = true);\n▣ p ∧ q\n└✔ YES\n\n▣ p ∧ ¬q\n└✔ NO\n\n▣ ¬p\n└✔ NO\n\n\nSee also AbstractModel, SoleLogics.CONJUNCTION, joinrules, listimmediaterules, LeafModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.negconsequent-Tuple{Branch}","page":"Full reference","title":"SoleModels.negconsequent","text":"negconsequent(m::Branch)::AbstractModel\n\nReturn the negative consequent of a branch; that is, the model to be applied if the antecedent evaluates to false.\n\nSee also antecedent, Branch, posconsequent.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.nimmediatesubmodels-Tuple{AbstractModel}","page":"Full reference","title":"SoleModels.nimmediatesubmodels","text":"nimmediatesubmodels(m::AbstractModel)\n\nReturn the number of models returned by immediatesubmodels.\n\nSee also AbstractModel, immediatesubmodels.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.nnodes-Tuple{DecisionEnsemble}","page":"Full reference","title":"SoleModels.nnodes","text":"function nnodes(m::DecisionEnsemble)\n\nReturn the number of nodes within m, that is, the sum of the nodes number in each wrapped DecisionTree.\n\nSee also DecisionEnsemble, DecisionTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.nnodes-Tuple{DecisionTree}","page":"Full reference","title":"SoleModels.nnodes","text":"function nnodes(m::DecisionTree)\n\nReturn the number of nodes in m.\n\nSee also DecisionTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.nsyntaxleaves-Tuple{AbstractModel}","page":"Full reference","title":"SoleModels.nsyntaxleaves","text":"atoms(::AbstractModel)\nconnectives(::AbstractModel)\nsyntaxleaves(::AbstractModel)\n\nnatoms(::AbstractModel)\nnconnectives(::AbstractModel)\nnsyntaxleaves(::AbstractModel)\n\nSee also AbstractModel, listrules.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.ntrees-Tuple{DecisionForest}","page":"Full reference","title":"SoleModels.ntrees","text":"function ntrees(m::DecisionForest)\n\nReturn the number of trees within m.\n\nSee also DecisionForest, DecisionTree, trees.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.outcome-Tuple{ConstantModel}","page":"Full reference","title":"SoleModels.outcome","text":"outcome(m::ConstantModel)\n\nReturn the constant outcome wrapped by m.\n\nSee also ConstantModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.outcometype-Union{Tuple{Type{<:AbstractModel{O}}}, Tuple{O}} where O","page":"Full reference","title":"SoleModels.outcometype","text":"outcometype(::Type{<:AbstractModel{O}}) where {O} = O\noutcometype(m::AbstractModel) = outcometype(typeof(m))\n\nReturn the outcome type of a model (type).\n\nSee also AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.outputtype-Tuple{AbstractModel}","page":"Full reference","title":"SoleModels.outputtype","text":"outputtype(m::AbstractModel)\n\nReturn a supertype for the outputs obtained when applying a model.\n\nImplementation\n\nThe result depends on whether the model is incomplete or complete\n\njulia> outputtype(m::AbstractModel{O}) where {O} = iscomplete(m) ? O : Union{Nothing,O}\n\nNote that if the model is complete, then outputtype(m) is equal to outcometype(m).\n\nSee also AbstractModel, apply, iscomplete, outcometype.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.parse_orange_decision_list","page":"Full reference","title":"SoleModels.parse_orange_decision_list","text":"parse_orange_decision_list(decision_list, ignoredefaultrule = false; featuretype = SoleData.VariableValue)\n\nParser for orange-style decision lists. Reference: https://orange3.readthedocs.io/projects/orange-visual-programming/en/latest/widgets/model/cn2ruleinduction.html\n\nArguments\n\ndecision_list is an AbstractString containing the orange-style representation of a decision list;\nignoredefaultrule is an optional, Boolean parameter indicating whether to use the default rule   as the default rule for the resulting decision list.   When false, the last rule is ignored, and the second last is used as the default rule;\nfeaturetype specifies the feature type used in the parsed ScalarConditions.\n\nExamples\n\njulia> dl = \"\n[49, 0, 0] IF petal length<=3.0 AND sepal width>=2.9 THEN iris=Iris-setosa  -0.0\n[0, 0, 39] IF petal width>=1.8 AND sepal length>=6.0 THEN iris=Iris-virginica  -0.0\n[0, 8, 0] IF sepal length>=4.9 AND sepal width>=3.1 THEN iris=Iris-versicolor  -0.0\n[0, 0, 2] IF petal length<=4.9 AND petal width>=1.7 THEN iris=Iris-virginica  -0.0\n[0, 0, 5] IF petal width>=1.8 THEN iris=Iris-virginica  -0.0\n[0, 35, 0] IF petal length<=5.0 AND sepal width>=2.4 THEN iris=Iris-versicolor  -0.0\n[0, 0, 2] IF sepal width>=2.8 THEN iris=Iris-virginica  -0.0\n[0, 3, 0] IF petal width<=1.0 AND sepal length>=5.0 THEN iris=Iris-versicolor  -0.0\n[0, 1, 0] IF sepal width>=2.7 THEN iris=Iris-versicolor  -0.0\n[0, 0, 1] IF sepal width>=2.6 THEN iris=Iris-virginica  -0.0\n[0, 2, 0] IF sepal length>=5.5 AND sepal length>=6.2 THEN iris=Iris-versicolor  -0.0\n[0, 1, 0] IF sepal length<=5.5 AND petal length>=4.0 THEN iris=Iris-versicolor  -0.0\n[0, 0, 1] IF sepal length>=6.0 THEN iris=Iris-virginica  -0.0\n[1, 0, 0] IF sepal length<=4.5 THEN iris=Iris-setosa  -0.0\n[50, 50, 50] IF TRUE THEN iris=Iris-setosa  -1.584962500721156\n\" |> SoleModels.parse_orange_decision_list\n\njulia> listrules(dl; normalize = true)\n15-element Vector{ClassificationRule{String}}:\n ▣ ((:petal_length ≤ 3.0) ∧ (:sepal_width ≥ 2.9))  ↣  Iris-setosa\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width ≥ 1.8) ∧ (:sepal_length ≥ 6.0))  ↣  Iris-virginica\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length ≥ 4.9) ∧ (:sepal_width ≥ 3.1))  ↣  Iris-versicolor\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length ≤ 4.9) ∧ (:petal_width ≥ 1.7))  ↣  Iris-virginica\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width ≥ 1.8)  ↣  Iris-virginica\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length ≤ 5.0) ∧ (:sepal_width ≥ 2.4))  ↣  Iris-versicolor\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width ≥ 2.8)  ↣  Iris-virginica\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width ≤ 1.0) ∧ (:sepal_length ≥ 5.0))  ↣  Iris-versicolor\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width ≥ 2.7)  ↣  Iris-versicolor\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width < 2.7) ∧ (:sepal_width ≥ 2.6)  ↣  Iris-virginica\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width < 2.7) ∧ (:sepal_width < 2.6) ∧ ((:sepal_length ≥ 5.5) ∧ (:sepal_length ≥ 6.2))  ↣  Iris-versicolor\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width < 2.7) ∧ (:sepal_width < 2.6) ∧ ((:sepal_length < 5.5) ∨ (:sepal_length < 6.2)) ∧ ((:sepal_length ≤ 5.5) ∧ (:petal_length ≥ 4.0))  ↣  Iris-versicolor\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width < 2.7) ∧ (:sepal_width < 2.6) ∧ ((:sepal_length < 5.5) ∨ (:sepal_length < 6.2)) ∧ ((:sepal_length > 5.5) ∨ (:petal_length < 4.0)) ∧ (:sepal_length ≥ 6.0)  ↣  Iris-virginica\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width < 2.7) ∧ (:sepal_width < 2.6) ∧ ((:sepal_length < 5.5) ∨ (:sepal_length < 6.2)) ∧ ((:sepal_length > 5.5) ∨ (:petal_length < 4.0)) ∧ (:sepal_length < 6.0) ∧ (:sepal_length ≤ 4.5)  ↣  Iris-setosa\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width < 2.7) ∧ (:sepal_width < 2.6) ∧ ((:sepal_length < 5.5) ∨ (:sepal_length < 6.2)) ∧ ((:sepal_length > 5.5) ∨ (:petal_length < 4.0)) ∧ (:sepal_length < 6.0) ∧ (:sepal_length > 4.5)  ↣  Iris-setosa\n\n\nSee also DecisionList.\n\n\n\n\n\n","category":"function"},{"location":"autodocs/#SoleModels.posconsequent-Tuple{Branch}","page":"Full reference","title":"SoleModels.posconsequent","text":"posconsequent(m::Branch)::AbstractModel\n\nReturn the positive consequent of a branch, that is, the model to be applied if the antecedent evaluates to true.\n\nSee also antecedent, Branch, negconsequent.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.printmodel-Tuple{AbstractModel}","page":"Full reference","title":"SoleModels.printmodel","text":"printmodel(io::IO, m::AbstractModel; kwargs...)\ndisplaymodel(m::AbstractModel; kwargs...)\n\nprint or return a string representation of model m.\n\nArguments\n\nheader::Bool = false: when set to true, a header is printed, displaying the info structure for m;\nshow_subtree_info::Bool = false: when set to true, the header is printed for models in the sub-tree of m;\nshow_metrics::Bool = false: when set to true, performance metrics at each point of the subtree are shown, whenever they are available in the info structure;\nmax_depth::Union{Nothing,Int} = nothing: when it is an Int, models in the sub-tree with a depth higher than max_depth are ellipsed with \"...\";\nsyntaxstring_kwargs::NamedTuple = (;): kwargs to be passed to syntaxstring for formatting logical formulas.\n\nSee also syntaxstring, AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.readmetrics-Union{Tuple{LeafModel{L}}, Tuple{L}} where L<:Union{AbstractString, Real, Symbol, CategoricalArrays.CategoricalValue}","page":"Full reference","title":"SoleModels.readmetrics","text":"readmetrics(m::AbstractModel; round_digits = nothing)\n\nReturn a NamedTuple with some performance metrics for the given symbolic model. Performance metrics can be computed when the info structure of the model has the following keys:\n\n:supporting_labels\n:supporting_predictions\n\nThe round_digits keyword argument, if provided, is used to round accuracy/confidence metrics.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.root-Tuple{DecisionTree}","page":"Full reference","title":"SoleModels.root","text":"root(m::DecisionTree)\n\nReturn the root of the tree m.\n\nSee also DecisionTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.root-Tuple{MixedModel}","page":"Full reference","title":"SoleModels.root","text":"root(m::MixedModel)\n\nReturn the root of model m.\n\nSee also MixedModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.rulebase-Tuple{DecisionList}","page":"Full reference","title":"SoleModels.rulebase","text":"rulebase(m::DecisionList)\n\nReturn the rulebase of m.\n\nSee also DecisionList, Rule.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.rulemetrics-Tuple{Rule, SoleLogics.AbstractInterpretationSet, AbstractVector{<:Union{AbstractString, Real, Symbol, CategoricalArrays.CategoricalValue}}}","page":"Full reference","title":"SoleModels.rulemetrics","text":"rulemetrics(\n    r::Rule,\n    X::AbstractInterpretationSet,\n    Y::AbstractVector{<:Label}\n)\n\nCompute metrics for a rule with respect to a labeled dataset and returns a NamedTuple consisting of:\n\ncoverage: number of instances satisfying the antecedent of the rule divided by   the total number of instances;\nerror:\nFor classification problems: number of instances that were not classified\ncorrectly divided by the total number of instances;\nFor regression problems: mean squared error;\nlength: number of atoms in the rule's antecedent.\n\nSee also Rule, SoleLogics.AbstractInterpretationSet, Label, evaluaterule, outcometype, consequent.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.solemodel","page":"Full reference","title":"SoleModels.solemodel","text":"solemodel(m::Any)\n\nThis function translates a symbolic model to a symbolic model using the structures defined in SoleModel.jl.\n\nSee also AbstractModel, ConstantModel, FunctionModel, LeafModel.\n\n\n\n\n\n","category":"function"},{"location":"autodocs/#SoleModels.submodels-Tuple{AbstractModel}","page":"Full reference","title":"SoleModels.submodels","text":"submodels(m::AbstractModel)\n\nEnumerate all submodels in the sub-tree. This function is the transitive closure of immediatesubmodels; in fact, the returned list includes the immediate submodels (immediatesubmodels(m)), but also their immediate submodels, and so on.\n\nExamples\n\njulia> using SoleLogics\n\njulia> branch = Branch(SoleLogics.parseformula(\"p∧q∨r\"), \"YES\", \"NO\");\n\njulia> submodels(branch)\n2-element Vector{SoleModels.ConstantModel{String}}:\n ConstantModel\nYES\n\n ConstantModel\nNO\n\n\njulia> branch2 = Branch(SoleLogics.parseformula(\"s→p\"), branch, 42);\n\njulia> printmodel.(submodels(branch2));\nBranch\n┐ p ∧ (q ∨ r)\n├ ✔ YES\n└ ✘ NO\n\nConstantModel\nYES\n\nConstantModel\nNO\n\nConstantModel\n42\n\njulia> submodels(branch) == immediatesubmodels(branch)\ntrue\n\njulia> submodels(branch2) == immediatesubmodels(branch2)\nfalse\n\nSee also AbstractModel, immediatesubmodels, LeafModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.syntaxleaves-Tuple{AbstractModel}","page":"Full reference","title":"SoleModels.syntaxleaves","text":"atoms(::AbstractModel)\nconnectives(::AbstractModel)\nsyntaxleaves(::AbstractModel)\n\nnatoms(::AbstractModel)\nnconnectives(::AbstractModel)\nnsyntaxleaves(::AbstractModel)\n\nSee also AbstractModel, listrules.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.trees-Tuple{DecisionForest}","page":"Full reference","title":"SoleModels.trees","text":"trees(m::DecisionForest)\n\nReturn all the DecisionTrees wrapped within a forest.\n\nSee also DecisionTree.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.wrap-Tuple{Any, Type{<:AbstractModel}}","page":"Full reference","title":"SoleModels.wrap","text":"wrap(o::Any, FM::Type{<:AbstractModel})\nwrap(m::AbstractModel)\nwrap(o::Any)::AbstractModel\n\nThis function wraps anything into an AbstractModel. The default behavior is the following:     - when called on an AbstractModel, the model is simply returned (no wrapping is         performed);     - Functions andFunctionWrappers are wrapped into a [FunctionModel](@ref);     - every other object is wrapped into aConstantModel`.\n\nSee also AbstractModel, ConstantModel, FunctionModel, LeafModel.\n\n\n\n\n\n","category":"method"},{"location":"logic/#Logical-foundations","page":"Logical foundations","title":"Logical foundations","text":"","category":"section"},{"location":"logic/","page":"Logical foundations","title":"Logical foundations","text":"SoleLogics lays the logical foundations for this package. While the full reference for SoleLogics can be found here, these are the basic logical concepts needed for symbolic modelling.","category":"page"},{"location":"logic/","page":"Logical foundations","title":"Logical foundations","text":"","category":"page"},{"location":"logic/#SoleLogics.Atom-logic","page":"Logical foundations","title":"SoleLogics.Atom","text":"struct Atom{V} <: AbstractAtom\n    value::V\nend\n\nSimplest atom implementation, wrapping a value.\n\nSee also AbstractAtom, value, check, SyntaxToken.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.CONJUNCTION-logic","page":"Logical foundations","title":"SoleLogics.CONJUNCTION","text":"const CONJUNCTION = NamedConnective{:∧}()\nconst ∧ = CONJUNCTION\narity(::typeof(∧)) = 2\n\nLogical conjunction. It can be typed by \\wedge<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"logic/#SoleLogics.DISJUNCTION-logic","page":"Logical foundations","title":"SoleLogics.DISJUNCTION","text":"const DISJUNCTION = NamedConnective{:∨}()\nconst ∨ = DISJUNCTION\narity(::typeof(∨)) = 2\n\nLogical disjunction. It can be typed by \\vee<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"logic/#SoleLogics.Formula-logic","page":"Logical foundations","title":"SoleLogics.Formula","text":"abstract type Formula <: Syntactical end\n\nAbstract type for logical formulas. Examples of Formulas are SyntaxLeafs (for example, Atoms and Truth values), SyntaxStructures (for example, SyntaxTrees and LeftmostLinearForms) and TruthTables ( enriched representation, which associates a syntactic structure with additional memoization structures, which can save computational time upon model checking).\n\nAny formula can be converted into its SyntaxTree representation via tree; its height can be computed, and it can be queried for its syntax tokens, atoms, etc... It can be parsed from its syntaxstring representation via parseformula.\n\nInterface\n\ntree(φ::Formula)::SyntaxTree\ncomposeformulas(c::Connective, φs::NTuple{N,F})::F where {N,F<:Formula}\nSee also Syntactical\n\nUtility functions (requiring a walk of the tree)\n\nBase.in(tok::SyntaxToken, φ::Formula)::Bool\nheight(φ::Formula)::Int\ntokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:AbstractAtom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Int\nnatoms(φ::Formula)::Int\nntruths(φ::Formula)::Int\nnleaves(φ::Formula)::Int\nnconnectives(φ::Formula)::Int\nnoperators(φ::Formula)::Int\n\nSee also tree, SyntaxStructure, SyntaxLeaf.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.syntaxstring-logic","page":"Logical foundations","title":"SoleLogics.syntaxstring","text":"syntaxstring(s::Syntactical; kwargs...)::String\n\nReturn the string representation of any syntactic object (e.g., Formula, SyntaxTree, SyntaxToken, Atom, Truth, etc). Note that this representation may introduce redundant parentheses. kwargs can be used to specify how to display syntax tokens/trees under some specific conditions.\n\nThe following kwargs are currently supported:\n\nfunction_notation = false::Bool: when set to true, it forces the use of  function notation for binary operators  (see here).\nremove_redundant_parentheses = true::Bool: when set to false, it prints a syntaxstring  where each syntactical element is wrapped in parentheses.\nparenthesize_atoms = !remove_redundant_parentheses::Bool: when set to true,  it forces the atoms (which are the leaves of a formula's tree structure) to be  wrapped in parentheses.\n\nExamples\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"))\n\"p ∧ q ∧ r ∧ s ∧ t\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), function_notation=true)\n\"∧(∧(∧(∧(p, q), r), s), t)\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), remove_redundant_parentheses=false)\n\"((((p) ∧ (q)) ∧ (r)) ∧ (s)) ∧ (t)\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), remove_redundant_parentheses=true, parenthesize_atoms=true)\n\"(p) ∧ (q) ∧ (r) ∧ (s) ∧ (t)\"\n\njulia> syntaxstring(parseformula(\"◊((p∧s)→q)\"))\n\"◊((p ∧ s) → q)\"\n\njulia> syntaxstring(parseformula(\"◊((p∧s)→q)\"); function_notation = true)\n\"◊(→(∧(p, s), q))\"\n\nSee also parseformula, SyntaxBranch, SyntaxToken.\n\nImplementation\n\nIn the case of a syntax tree, syntaxstring is a recursive function that calls itself on the syntax children of each node. For a correct functioning, the syntaxstring must be defined (including the kwargs... part!) for every newly defined SyntaxToken (e.g., SyntaxLeafs, that is, Atoms and Truth values, and Operators), in a way that it produces a unique string representation, since Base.hash and Base.isequal, at least for SyntaxTrees, rely on it.\n\nIn particular, for the case of Atoms, the function calls itself on the wrapped value:\n\nsyntaxstring(a::Atom; kwargs...) = syntaxstring(value(a); kwargs...)\n\nThe syntaxstring for any value defaults to its string representation, but it can be defined by defining the appropriate syntaxstring method.\n\nwarning: Warning\nThe syntaxstring for syntax tokens (e.g., atoms, operators) should not be prefixed/suffixed by whitespaces, as this may cause ambiguities upon parsing. For similar reasons, syntaxstrings should not contain parentheses ('(', ')'), and, when parsing in function notation, commas (',').\n\nSee also SyntaxLeaf, Operator, parseformula.\n\n\n\n\n\n","category":"function"},{"location":"logic/#SoleLogics.AbstractAlphabet-logic","page":"Logical foundations","title":"SoleLogics.AbstractAlphabet","text":"abstract type AbstractAlphabet{V} end\n\nAbstract type for representing an alphabet of atoms with values of type V. An alphabet (or propositional alphabet) is a set of atoms (assumed to be countable).\n\nExamples\n\njulia> Atom(1) in ExplicitAlphabet(Atom.(1:10))\ntrue\n\njulia> Atom(1) in ExplicitAlphabet(1:10)\ntrue\n\njulia> Atom(1) in AlphabetOfAny{String}()\nfalse\n\njulia> Atom(\"mystring\") in AlphabetOfAny{String}()\ntrue\n\njulia> \"mystring\" in AlphabetOfAny{String}()\n┌ Warning: Please, use Base.in(Atom(mystring), alphabet::AlphabetOfAny{String}) instead of Base.in(mystring, alphabet::AlphabetOfAny{String})\n└ @ SoleLogics ...\ntrue\n\nInterface\n\natoms(a::AbstractAlphabet)::AbstractVector\nBase.isfinite(::Type{<:AbstractAlphabet})::Bool\nrandatom(rng::Union{Random.AbstractRNG, Integer}, a::AbstractAlphabet, args...; kwargs...)::AbstractAtom\n\nUtility functions\n\nnatoms(a::AbstractAlphabet)::Bool\nBase.in(p::AbstractAtom, a::AbstractAlphabet)::Bool\nBase.eltype(a::AbstractAlphabet)\nrandatom(a::AbstractAlphabet, args...; kwargs...)::AbstractAtom\natomstype(a::AbstractAlphabet)\nvaluetype(a::AbstractAlphabet)\n\nImplementation\n\nWhen implementing a new alphabet type MyAlphabet, you should provide a method for establishing whether an atom belongs to it or not; while, in general, this method should be:\n\nfunction Base.in(p::AbstractAtom, a::MyAlphabet)::Bool\n\nin the case of finite alphabets, it suffices to define a method:\n\nfunction atoms(a::AbstractAlphabet)::AbstractVector{atomstype(a)}\n\nBy default, an alphabet is considered finite:\n\nBase.isfinite(::Type{<:AbstractAlphabet}) = true\nBase.isfinite(a::AbstractAlphabet) = Base.isfinite(typeof(a))\nBase.in(p::AbstractAtom, a::AbstractAlphabet) = Base.isfinite(a) ? Base.in(p, atoms(a)) : error(...)\n\nSee also AbstractGrammar, AlphabetOfAny, AbstractAtom, ExplicitAlphabet.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.AbstractInterpretation-logic","page":"Logical foundations","title":"SoleLogics.AbstractInterpretation","text":"abstract type AbstractInterpretation end\n\nAbstract type for representing a logical interpretation. In the case of propositional logic, is essentially a map atom → truth value.\n\nProperties expressed via logical formulas can be checked on logical interpretations.\n\nInterface\n\nvaluetype(i::AbstractInterpretation)\ntruthtype(i::AbstractInterpretation)\ninterpret(φ::Formula, i::AbstractInterpretation, args...; kwargs...)::Formula\n\nUtility functions\n\ncheck(φ::Formula, i::AbstractInterpretation, args...; kwargs...)::Bool\n\nSee also check, AbstractAssignment, AbstractKripkeStructure.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.AbstractInterpretationSet-logic","page":"Logical foundations","title":"SoleLogics.AbstractInterpretationSet","text":"abstract type AbstractInterpretationSet <: AbstractDataset end\n\nAbstract type for ordered sets of interpretations. A set of interpretations, also referred to as a dataset in this context, is a collection of instances, each of which is an interpretation, and is identified by an index iinstance::Integer. These structures are especially useful when performing [model checking](https://en.wikipedia.org/wiki/Modelchecking).\n\nInterface\n\ninterpretationtype(S)\nalphabet(s)\ngetinstance(s)\nconcatdatasets(ss...)\ninstances(s, idxs, return_view; kwargs...)\nninstances(s)\n\nUtility Functions\n\nvaluetype(s)\ntruthtype(s)\nslicedataset(s, idxs; kwargs...)\neachinstance(s)\n\nUtility Functions (with more-than-propositional logics)\n\nworldtype(s)\nframetype(s)\nframe(s, i_instance)\naccessibles(s, i_instance, args...)\nallworlds(s, i_instance, args...)\nnworlds(s, i_instance)\n\nSee also InterpretationVector.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.check-logic","page":"Logical foundations","title":"SoleLogics.check","text":"check(\n    φ::Formula,\n    i::AbstractInterpretation,\n    args...;\n    kwargs...\n)::Bool\n\nCheck a formula on a logical interpretation (or model), returning true if the truth value for the formula istop. This process is referred to as (finite) model checking, and there are many algorithms for it, typically depending on the complexity of the logic.\n\nExamples\n\njulia> @atoms String p q\n2-element Vector{Atom{String}}:\n Atom{String}(\"p\")\n Atom{String}(\"q\")\n\njulia> td = TruthDict([p => TOP, q => BOT])\nTruthDict with values:\n┌────────┬────────┐\n│      q │      p │\n│ String │ String │\n├────────┼────────┤\n│      ⊥ │      ⊤ │\n└────────┴────────┘\n\njulia> check(CONJUNCTION(p,q), td)\nfalse\n\nSee also interpret, Formula, AbstractInterpretation, TruthDict.\n\n\n\n\n\ncheck(φ::Formula, i::Union{AbstractDict, AbstractVector}, args...)\n\nTakes a Formula as input and returns its truth value in relation to the dictionary  or vector passed. We let any AbstractDict and AbstractVector be used as an interpretation  when model checking.\n\nSee also Formula.\n\n\n\n\n\ncheck(a::Atom, i::AbstractDict)\n\nReturns the Boolean value corresponding to the atom passed as parameter.\n\nExamples\n\njulia> check(Atom(1), Dict([1 => ⊤, 2 => ⊥]))\ntrue\n\njulia> check(Atom(3), Dict([1 => ⊤, 2 => ⊥]))\nfalse\n\nSee also Atom.\n\n\n\n\n\ncheck(a::Atom, i::AbstractVector)\n\nReturns a truth value indicating whether or not that Atom  is contained in the passed vector.\n\nExamples\n\njulia> check(Atom(1), [1,2,4])\ntrue\n\njulia> check(Atom(5), [2,3,4])\nfalse\n\nSee also Atom.\n\n\n\n\n\nfunction check(\n    φ::SyntaxTree,\n    i::AbstractKripkeStructure,\n    w::Union{Nothing,AnyWorld,<:AbstractWorld} = nothing;\n    use_memo::Union{Nothing,AbstractDict{<:Formula,<:Vector{<:AbstractWorld}}} = nothing,\n    perform_normalization::Bool = true,\n    memo_max_height::Union{Nothing,Int} = nothing,\n)::Bool\n\nCheck a formula on a specific word in a KripkeStructure.\n\nExamples\n\njulia> using Graphs, Random\n\njulia> @atoms String p q\n2-element Vector{Atom{String}}:\n Atom{String}(\"p\")\n Atom{String}(\"q\")\n\njulia> fmodal = randformula(Random.MersenneTwister(14), 3, [p,q], SoleLogics.BASE_MODAL_CONNECTIVES)\n¬□(p ∨ q)\n\n# A special graph, called Kripke Frame, is created.\n# Nodes are called worlds, and the edges are relations between worlds.\njulia> worlds = SoleLogics.World.(1:5) # 5 worlds are created, numerated from 1 to 5\n\njulia> edges = Edge.([(1,2), (1,3), (2,4), (3,4), (3,5)])\n\njulia> kframe = SoleLogics.ExplicitCrispUniModalFrame(worlds, Graphs.SimpleDiGraph(edges))\n\n# A valuation function establishes which fact are true on each world\njulia> valuation = Dict([\n    worlds[1] => TruthDict([p => true, q => false]),\n    worlds[2] => TruthDict([p => true, q => true]),\n    worlds[3] => TruthDict([p => true, q => false]),\n    worlds[4] => TruthDict([p => false, q => false]),\n    worlds[5] => TruthDict([p => false, q => true]),\n ])\n\n# Kripke Frame and valuation function are merged in a Kripke Structure\njulia> kstruct = KripkeStructure(kframe, valuation)\n\njulia> [w => check(fmodal, kstruct, w) for w in worlds]\n5-element Vector{Pair{SoleLogics.World{Int64}, Bool}}:\n SoleLogics.World{Int64}(1) => 0\n SoleLogics.World{Int64}(2) => 1\n SoleLogics.World{Int64}(3) => 1\n SoleLogics.World{Int64}(4) => 0\n SoleLogics.World{Int64}(5) => 0\n\nSee also SyntaxTree, AbstractWorld, KripkeStructure.\n\n\n\n\n\ncheck(\n    φ::Formula,\n    s::AbstractInterpretationSet,\n    i_instance::Integer,\n    args...;\n    kwargs...\n)::Bool\n\nCheck a formula on the i-th instance of an AbstractInterpretationSet.\n\nSee also AbstractInterpretationSet, Formula.\n\n\n\n\n\ncheck(\n    φ::Formula,\n    s::AbstractInterpretationSet,\n    args...;\n    kwargs...\n)::Vector{Bool}\n\nCheck a formula on all instances of an AbstractInterpretationSet.\n\nSee also AbstractInterpretationSet, Formula.\n\n\n\n\n\ncheck(\n    φ::SoleLogics.SyntaxTree,\n    i::SoleLogics.LogicalInstance{<:AbstractModalLogiset{W,<:U}},\n    w::Union{Nothing,AnyWorld,<:AbstractWorld} = nothing;\n    kwargs...\n)::Bool\n\nCheck whether a formula φ holds for a given instance i_instance of a logiset X, on a world w. Note that the world can be elided for grounded formulas (see isgrounded).\n\nThis implementation recursively evaluates the subformulas of φ and use memoization to store the results using Emerson-Clarke algorithm. The memoization structure is either the one stored in X itself (if X supports memoization) or a structure passed as the use_memo argument. If X supports onestep memoization, then it will be used for specific diamond formulas, up to an height equal to a keyword argument memo_max_height.\n\nArguments\n\nφ::SoleLogics.SyntaxTree: the formula to check.\ni::SoleLogics.LogicalInstance{<:AbstractModalLogiset{W,<:U}}: the instance of the logiset to check in.\nw::Union{Nothing,AnyWorld,<:AbstractWorld} = nothing: the world to check in. If nothing, the method checks in all worlds of the instance.\n\nKeyword arguments\n\nuse_memo::Union{Nothing,AbstractMemoset{<:AbstractWorld},AbstractVector{<:AbstractDict{<:FT,<:AbstractWorlds}}} = nothing: the memoization structure to use. If nothing, the method uses the one stored in X if X supports memoization. If AbstractMemoset, the method uses the i_instance-th element of the memoization structure. If AbstractVector, the method uses the i_instance-th element of the vector.\nperform_normalization::Bool = true: whether to normalize the formula before checking it.\nmemo_max_height::Union{Nothing,Int} = nothing: the maximum height up to which onestep memoization should be used. If nothing, the method does not use onestep memoization.\nonestep_memoset_is_complete = false: whether the onestep memoization structure is complete (i.e. it contains all possible values of the metaconditions in the structure).\n\n\n\n\n\n","category":"function"},{"location":"logic/#SoleLogics.AbstractWorld-logic","page":"Logical foundations","title":"SoleLogics.AbstractWorld","text":"abstract type AbstractWorld end\n\nAbstract type for the nodes of an annotated accessibility graph (Kripke structure). This is used, for example, in modal logic, where the truth of formulas is relativized to worlds, that is, nodes of a graph.\n\nImplementing\n\nWhen implementing a new world type, the logical semantics should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also AbstractKripkeStructure, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.GeometricalWorld-logic","page":"Logical foundations","title":"SoleLogics.GeometricalWorld","text":"abstract type GeometricalWorld <: AbstractWorld end\n\nAbstract type for worlds with a geometrical interpretation.\n\nSee also Point, Interval, Interval2D, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.Interval-logic","page":"Logical foundations","title":"SoleLogics.Interval","text":"struct Interval{T<:Real} <: GeometricalWorld\n    x :: T\n    y :: T\nend\n\nAn interval in a 1-dimensional space, with coordinates of type T.\n\nExamples\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval(1,2),1)\ntrue\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval(1,2),2)\nfalse\n\njulia> collect(accessibles(SoleLogics.FullDimensionalFrame(5), Interval(1,2), SoleLogics.IA_L))\n6-element Vector{Interval{Int64}}:\n (3−4)\n (3−5)\n (4−5)\n (3−6)\n (4−6)\n (5−6)\n\n\n\nSee also goeswithdim, accessibles, FullDimensionalFrame, Point, Interval2D, GeometricalWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.Interval2D-logic","page":"Logical foundations","title":"SoleLogics.Interval2D","text":"struct Interval2D{T<:Real} <: GeometricalWorld\n    x :: Interval{T}\n    y :: Interval{T}\nend\n\nA orthogonal rectangle in a 2-dimensional space, with coordinates of type T. This is the 2-dimensional Interval counterpart, that is, the combination of two orthogonal Intervals.\n\nExamples\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),1)\nfalse\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),2)\ntrue\n\njulia> collect(accessibles(SoleLogics.FullDimensionalFrame(5,5), Interval2D((2,3),(2,4)), SoleLogics.IA_LL))\n3-element Vector{Interval2D{Int64}}:\n ((4−5)×(5−6))\n ((4−6)×(5−6))\n ((5−6)×(5−6))\n\n\nSee also goeswithdim, accessibles, FullDimensionalFrame, Point, Interval, GeometricalWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.AbstractRelation-logic","page":"Logical foundations","title":"SoleLogics.AbstractRelation","text":"abstract type AbstractRelation end\n\nAbstract type for the relations of a multi-modal annotated accessibility graph (Kripke structure). Two noteworthy relations are identityrel and globalrel, which access the current world and all worlds, respectively.\n\nExamples\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,), Interval{Int});\n\njulia> Interval(8,11) in (accessibles(fr, Interval(2,5), IA_L))\ntrue\n\nImplementation\n\nWhen implementing a new relation type R, please provide the methods:\n\narity(::R)::Int = ...\nsyntaxstring(::R; kwargs...)::String = ...\n\nIf the relation is symmetric, please specify its converse relation cr with:\n\nhasconverse(::R) = true\nconverse(::R) = cr\n\nIf the relation is many-to-one or one-to-one, please flag it with:\n\nistoone(::R) = true\n\nIf the relation is reflexive or transitive, flag it with:\n\nisreflexive(::R) = true\nistransitive(::R) = true\n\nMost importantly, the logical semantics for R should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also issymmetric, isreflexive, istransitive, isgrounding, arity, syntaxstring, converse, hasconverse, istoone, identityrel, globalrel, accessibles, AbstractKripkeStructure, AbstractFrame, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.globalrel-logic","page":"Logical foundations","title":"SoleLogics.globalrel","text":"struct GlobalRel <: AbstractRelation end;\nconst globalrel  = GlobalRel();\n\nSingleton type for the global relation. This is a binary relation via which a world accesses every other world within the frame. The relation is also symmetric, reflexive and transitive.\n\nExamples\n\njulia> syntaxstring(SoleLogics.globalrel)\n\"G\"\n\njulia> SoleLogics.converse(globalrel)\nGlobalRel()\n\nSee also identityrel, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"constant"},{"location":"logic/#SoleLogics.IA_L-logic","page":"Logical foundations","title":"SoleLogics.IA_L","text":"See IntervalRelation.\n\n\n\n\n\n","category":"constant"},{"location":"logic/#SoleLogics.AbstractFrame-logic","page":"Logical foundations","title":"SoleLogics.AbstractFrame","text":"abstract type AbstractFrame{W<:AbstractWorld} end\n\nAbstract type for an accessibility graph (Kripke frame), that gives the topology to Kripke structures. A frame can be queried for its set of vertices (also called worlds, see allworlds), and it can be browsed via its accessibility relation(s) (see accessibles). Refer to FullDimensionalFrame as an example.\n\nSee also truthtype, , allworlds, nworlds, AbstractKripkeStructure, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.AbstractKripkeStructure-logic","page":"Logical foundations","title":"SoleLogics.AbstractKripkeStructure","text":"abstract type AbstractKripkeStructure <: AbstractInterpretation end\n\nAbstract type for representing Kripke structures's. It comprehends a directed graph structure (Kripke frame), where nodes are referred to as worlds, and the binary relation between them is referred to as the accessibility relation. Additionally, each world is associated with a mapping from Atoms to Truth values.\n\nSee also frame, worldtype, accessibles, AbstractInterpretation.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.accessibles-logic","page":"Logical foundations","title":"SoleLogics.accessibles","text":"accessibles(fr::AbstractUniModalFrame{W}, w::W)::Worlds{W} where {W<:AbstractWorld}\n\nReturn the worlds in frame fr that are accessible from world w.\n\nSee also AbstractWorld, AbstractUniModalFrame.\n\n\n\n\n\naccessibles(\n    fr::AbstractMultiModalFrame{W},\n    w::W,\n    r::AbstractRelation\n) where {W<:AbstractWorld}\n\nReturn the worlds in frame fr that are accessible from world w via relation r.\n\nExamples\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,), Interval{Int});\n\njulia> typeof(accessibles(fr, Interval(2,5), IA_L))\nBase.Generator{...}\n\njulia> typeof(accessibles(fr, globalrel))\nBase.Generator{...}\n\njulia> @assert SoleLogics.nworlds(fr) == length(collect(accessibles(fr, globalrel)))\n\njulia> typeof(accessibles(fr, Interval(2,5), identityrel))\nVector{Interval{Int64}}\n\njulia> Interval(8,11) in collect(accessibles(fr, Interval(2,5), IA_L))\ntrue\n\nImplementation\n\nSince accessibles always returns an iterator to worlds of the same type W, the current implementation of accessibles for multi-modal frames delegates the enumeration to a lower level _accessibles function, which returns an iterator to parameter tuples that are, then, fed to the world constructor the using IterTools generators, as in:\n\nfunction accessibles(\n    fr::AbstractMultiModalFrame{W},\n    w::W,\n    r::AbstractRelation,\n) where {W<:AbstractWorld}\n    IterTools.imap(W, _accessibles(fr, w, r))\nend\n\nAs such, when defining new frames, worlds, and/or relations, one should provide new methods for _accessibles. For example:\n\n_accessibles(fr::Full1DFrame, w::Interval{<:Integer}, ::_IA_A) = zip(Iterators.repeated(w.y), w.y+1:X(fr)+1)\n\nThis pattern is generally convenient; it can, however, be bypassed, although this requires defining two additional methods in order to resolve dispatch ambiguities. When defining a new frame type FR{W}, one can resolve the ambiguities and define a custom accessibles method by providing these three methods:\n\n# access worlds through relation `r`\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::AbstractRelation,\n) where {W<:AbstractWorld}\n    ...\nend\n\n# access current world\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::IdentityRel,\n) where {W<:AbstractWorld}\n    [w]\nend\n\n# access all worlds\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::GlobalRel,\n) where {W<:AbstractWorld}\n    allworlds(fr)\nend\n\nIn general, it should be true that collect(accessibles(fr, w, r)) isa AbstractWorlds{W}.\n\nSee also AbstractWorld, AbstractRelation, AbstractMultiModalFrame.\n\n\n\n\n\n","category":"function"}]
}
